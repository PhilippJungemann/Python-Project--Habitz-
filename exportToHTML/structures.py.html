<html>
<head>
<title>structures.py</title>
<meta http-equiv="Content-Type" content="text/html; charset=utf-8">
<style type="text/css">
.s0 { color: #cc7832;}
.s1 { color: #a9b7c6;}
.s2 { color: #6a8759;}
.s3 { color: #6897bb;}
.s4 { color: #629755; font-style: italic;}
.s5 { color: #808080;}
</style>
</head>
<body bgcolor="#2b2b2b">
<table CELLSPACING=0 CELLPADDING=5 COLS=1 WIDTH="100%" BGCOLOR="#606060" >
<tr><td><center>
<font face="Arial, Helvetica" color="#000000">
structures.py</font>
</center></td></tr></table>
<pre><span class="s0">import </span><span class="s1">collections.abc</span>
<span class="s0">import </span><span class="s1">inspect</span>
<span class="s0">import </span><span class="s1">warnings</span>
<span class="s0">from </span><span class="s1">typing </span><span class="s0">import </span><span class="s1">Any</span>
<span class="s0">from </span><span class="s1">typing </span><span class="s0">import </span><span class="s1">Callable</span>
<span class="s0">from </span><span class="s1">typing </span><span class="s0">import </span><span class="s1">Collection</span>
<span class="s0">from </span><span class="s1">typing </span><span class="s0">import </span><span class="s1">Iterable</span>
<span class="s0">from </span><span class="s1">typing </span><span class="s0">import </span><span class="s1">Iterator</span>
<span class="s0">from </span><span class="s1">typing </span><span class="s0">import </span><span class="s1">List</span>
<span class="s0">from </span><span class="s1">typing </span><span class="s0">import </span><span class="s1">Mapping</span>
<span class="s0">from </span><span class="s1">typing </span><span class="s0">import </span><span class="s1">MutableMapping</span>
<span class="s0">from </span><span class="s1">typing </span><span class="s0">import </span><span class="s1">NamedTuple</span>
<span class="s0">from </span><span class="s1">typing </span><span class="s0">import </span><span class="s1">Optional</span>
<span class="s0">from </span><span class="s1">typing </span><span class="s0">import </span><span class="s1">overload</span>
<span class="s0">from </span><span class="s1">typing </span><span class="s0">import </span><span class="s1">Sequence</span>
<span class="s0">from </span><span class="s1">typing </span><span class="s0">import </span><span class="s1">Set</span>
<span class="s0">from </span><span class="s1">typing </span><span class="s0">import </span><span class="s1">Tuple</span>
<span class="s0">from </span><span class="s1">typing </span><span class="s0">import </span><span class="s1">Type</span>
<span class="s0">from </span><span class="s1">typing </span><span class="s0">import </span><span class="s1">TYPE_CHECKING</span>
<span class="s0">from </span><span class="s1">typing </span><span class="s0">import </span><span class="s1">TypeVar</span>
<span class="s0">from </span><span class="s1">typing </span><span class="s0">import </span><span class="s1">Union</span>

<span class="s0">import </span><span class="s1">attr</span>

<span class="s0">from </span><span class="s1">.._code </span><span class="s0">import </span><span class="s1">getfslineno</span>
<span class="s0">from </span><span class="s1">..compat </span><span class="s0">import </span><span class="s1">ascii_escaped</span>
<span class="s0">from </span><span class="s1">..compat </span><span class="s0">import </span><span class="s1">final</span>
<span class="s0">from </span><span class="s1">..compat </span><span class="s0">import </span><span class="s1">NOTSET</span>
<span class="s0">from </span><span class="s1">..compat </span><span class="s0">import </span><span class="s1">NotSetType</span>
<span class="s0">from </span><span class="s1">_pytest.config </span><span class="s0">import </span><span class="s1">Config</span>
<span class="s0">from </span><span class="s1">_pytest.deprecated </span><span class="s0">import </span><span class="s1">check_ispytest</span>
<span class="s0">from </span><span class="s1">_pytest.outcomes </span><span class="s0">import </span><span class="s1">fail</span>
<span class="s0">from </span><span class="s1">_pytest.warning_types </span><span class="s0">import </span><span class="s1">PytestUnknownMarkWarning</span>

<span class="s0">if </span><span class="s1">TYPE_CHECKING:</span>
    <span class="s0">from </span><span class="s1">..nodes </span><span class="s0">import </span><span class="s1">Node</span>


<span class="s1">EMPTY_PARAMETERSET_OPTION = </span><span class="s2">&quot;empty_parameter_set_mark&quot;</span>


<span class="s0">def </span><span class="s1">istestfunc(func) -&gt; bool:</span>
    <span class="s0">return </span><span class="s1">callable(func) </span><span class="s0">and </span><span class="s1">getattr(func</span><span class="s0">, </span><span class="s2">&quot;__name__&quot;</span><span class="s0">, </span><span class="s2">&quot;&lt;lambda&gt;&quot;</span><span class="s1">) != </span><span class="s2">&quot;&lt;lambda&gt;&quot;</span>


<span class="s0">def </span><span class="s1">get_empty_parameterset_mark(</span>
    <span class="s1">config: Config</span><span class="s0">, </span><span class="s1">argnames: Sequence[str]</span><span class="s0">, </span><span class="s1">func</span>
<span class="s1">) -&gt; </span><span class="s2">&quot;MarkDecorator&quot;</span><span class="s1">:</span>
    <span class="s0">from </span><span class="s1">..nodes </span><span class="s0">import </span><span class="s1">Collector</span>

    <span class="s1">fs</span><span class="s0">, </span><span class="s1">lineno = getfslineno(func)</span>
    <span class="s1">reason = </span><span class="s2">&quot;got empty parameter set %r, function %s at %s:%d&quot; </span><span class="s1">% (</span>
        <span class="s1">argnames</span><span class="s0">,</span>
        <span class="s1">func.__name__</span><span class="s0">,</span>
        <span class="s1">fs</span><span class="s0">,</span>
        <span class="s1">lineno</span><span class="s0">,</span>
    <span class="s1">)</span>

    <span class="s1">requested_mark = config.getini(EMPTY_PARAMETERSET_OPTION)</span>
    <span class="s0">if </span><span class="s1">requested_mark </span><span class="s0">in </span><span class="s1">(</span><span class="s2">&quot;&quot;</span><span class="s0">, None, </span><span class="s2">&quot;skip&quot;</span><span class="s1">):</span>
        <span class="s1">mark = MARK_GEN.skip(reason=reason)</span>
    <span class="s0">elif </span><span class="s1">requested_mark == </span><span class="s2">&quot;xfail&quot;</span><span class="s1">:</span>
        <span class="s1">mark = MARK_GEN.xfail(reason=reason</span><span class="s0">, </span><span class="s1">run=</span><span class="s0">False</span><span class="s1">)</span>
    <span class="s0">elif </span><span class="s1">requested_mark == </span><span class="s2">&quot;fail_at_collect&quot;</span><span class="s1">:</span>
        <span class="s1">f_name = func.__name__</span>
        <span class="s1">_</span><span class="s0">, </span><span class="s1">lineno = getfslineno(func)</span>
        <span class="s0">raise </span><span class="s1">Collector.CollectError(</span>
            <span class="s2">&quot;Empty parameter set in '%s' at line %d&quot; </span><span class="s1">% (f_name</span><span class="s0">, </span><span class="s1">lineno + </span><span class="s3">1</span><span class="s1">)</span>
        <span class="s1">)</span>
    <span class="s0">else</span><span class="s1">:</span>
        <span class="s0">raise </span><span class="s1">LookupError(requested_mark)</span>
    <span class="s0">return </span><span class="s1">mark</span>


<span class="s0">class </span><span class="s1">ParameterSet(NamedTuple):</span>
    <span class="s1">values: Sequence[Union[object</span><span class="s0">, </span><span class="s1">NotSetType]]</span>
    <span class="s1">marks: Collection[Union[</span><span class="s2">&quot;MarkDecorator&quot;</span><span class="s0">, </span><span class="s2">&quot;Mark&quot;</span><span class="s1">]]</span>
    <span class="s1">id: Optional[str]</span>

    <span class="s1">@classmethod</span>
    <span class="s0">def </span><span class="s1">param(</span>
        <span class="s1">cls</span><span class="s0">,</span>
        <span class="s1">*values: object</span><span class="s0">,</span>
        <span class="s1">marks: Union[</span><span class="s2">&quot;MarkDecorator&quot;</span><span class="s0">, </span><span class="s1">Collection[Union[</span><span class="s2">&quot;MarkDecorator&quot;</span><span class="s0">, </span><span class="s2">&quot;Mark&quot;</span><span class="s1">]]] = ()</span><span class="s0">,</span>
        <span class="s1">id: Optional[str] = </span><span class="s0">None,</span>
    <span class="s1">) -&gt; </span><span class="s2">&quot;ParameterSet&quot;</span><span class="s1">:</span>
        <span class="s0">if </span><span class="s1">isinstance(marks</span><span class="s0">, </span><span class="s1">MarkDecorator):</span>
            <span class="s1">marks = (marks</span><span class="s0">,</span><span class="s1">)</span>
        <span class="s0">else</span><span class="s1">:</span>
            <span class="s0">assert </span><span class="s1">isinstance(marks</span><span class="s0">, </span><span class="s1">collections.abc.Collection)</span>

        <span class="s0">if </span><span class="s1">id </span><span class="s0">is not None</span><span class="s1">:</span>
            <span class="s0">if not </span><span class="s1">isinstance(id</span><span class="s0">, </span><span class="s1">str):</span>
                <span class="s0">raise </span><span class="s1">TypeError(</span><span class="s2">f&quot;Expected id to be a string, got </span><span class="s0">{</span><span class="s1">type(id)</span><span class="s0">}</span><span class="s2">: </span><span class="s0">{</span><span class="s1">id</span><span class="s0">!r}</span><span class="s2">&quot;</span><span class="s1">)</span>
            <span class="s1">id = ascii_escaped(id)</span>
        <span class="s0">return </span><span class="s1">cls(values</span><span class="s0">, </span><span class="s1">marks</span><span class="s0">, </span><span class="s1">id)</span>

    <span class="s1">@classmethod</span>
    <span class="s0">def </span><span class="s1">extract_from(</span>
        <span class="s1">cls</span><span class="s0">,</span>
        <span class="s1">parameterset: Union[</span><span class="s2">&quot;ParameterSet&quot;</span><span class="s0">, </span><span class="s1">Sequence[object]</span><span class="s0">, </span><span class="s1">object]</span><span class="s0">,</span>
        <span class="s1">force_tuple: bool = </span><span class="s0">False,</span>
    <span class="s1">) -&gt; </span><span class="s2">&quot;ParameterSet&quot;</span><span class="s1">:</span>
        <span class="s4">&quot;&quot;&quot;Extract from an object or objects. 
 
        :param parameterset: 
            A legacy style parameterset that may or may not be a tuple, 
            and may or may not be wrapped into a mess of mark objects. 
 
        :param force_tuple: 
            Enforce tuple wrapping so single argument tuple values 
            don't get decomposed and break tests. 
        &quot;&quot;&quot;</span>

        <span class="s0">if </span><span class="s1">isinstance(parameterset</span><span class="s0">, </span><span class="s1">cls):</span>
            <span class="s0">return </span><span class="s1">parameterset</span>
        <span class="s0">if </span><span class="s1">force_tuple:</span>
            <span class="s0">return </span><span class="s1">cls.param(parameterset)</span>
        <span class="s0">else</span><span class="s1">:</span>
            <span class="s5"># TODO: Refactor to fix this type-ignore. Currently the following</span>
            <span class="s5"># passes type-checking but crashes:</span>
            <span class="s5">#</span>
            <span class="s5">#   @pytest.mark.parametrize(('x', 'y'), [1, 2])</span>
            <span class="s5">#   def test_foo(x, y): pass</span>
            <span class="s0">return </span><span class="s1">cls(parameterset</span><span class="s0">, </span><span class="s1">marks=[]</span><span class="s0">, </span><span class="s1">id=</span><span class="s0">None</span><span class="s1">)  </span><span class="s5"># type: ignore[arg-type]</span>

    <span class="s1">@staticmethod</span>
    <span class="s0">def </span><span class="s1">_parse_parametrize_args(</span>
        <span class="s1">argnames: Union[str</span><span class="s0">, </span><span class="s1">List[str]</span><span class="s0">, </span><span class="s1">Tuple[str</span><span class="s0">, </span><span class="s1">...]]</span><span class="s0">,</span>
        <span class="s1">argvalues: Iterable[Union[</span><span class="s2">&quot;ParameterSet&quot;</span><span class="s0">, </span><span class="s1">Sequence[object]</span><span class="s0">, </span><span class="s1">object]]</span><span class="s0">,</span>
        <span class="s1">*args</span><span class="s0">,</span>
        <span class="s1">**kwargs</span><span class="s0">,</span>
    <span class="s1">) -&gt; Tuple[Union[List[str]</span><span class="s0">, </span><span class="s1">Tuple[str</span><span class="s0">, </span><span class="s1">...]]</span><span class="s0">, </span><span class="s1">bool]:</span>
        <span class="s0">if not </span><span class="s1">isinstance(argnames</span><span class="s0">, </span><span class="s1">(tuple</span><span class="s0">, </span><span class="s1">list)):</span>
            <span class="s1">argnames = [x.strip() </span><span class="s0">for </span><span class="s1">x </span><span class="s0">in </span><span class="s1">argnames.split(</span><span class="s2">&quot;,&quot;</span><span class="s1">) </span><span class="s0">if </span><span class="s1">x.strip()]</span>
            <span class="s1">force_tuple = len(argnames) == </span><span class="s3">1</span>
        <span class="s0">else</span><span class="s1">:</span>
            <span class="s1">force_tuple = </span><span class="s0">False</span>
        <span class="s0">return </span><span class="s1">argnames</span><span class="s0">, </span><span class="s1">force_tuple</span>

    <span class="s1">@staticmethod</span>
    <span class="s0">def </span><span class="s1">_parse_parametrize_parameters(</span>
        <span class="s1">argvalues: Iterable[Union[</span><span class="s2">&quot;ParameterSet&quot;</span><span class="s0">, </span><span class="s1">Sequence[object]</span><span class="s0">, </span><span class="s1">object]]</span><span class="s0">,</span>
        <span class="s1">force_tuple: bool</span><span class="s0">,</span>
    <span class="s1">) -&gt; List[</span><span class="s2">&quot;ParameterSet&quot;</span><span class="s1">]:</span>
        <span class="s0">return </span><span class="s1">[</span>
            <span class="s1">ParameterSet.extract_from(x</span><span class="s0">, </span><span class="s1">force_tuple=force_tuple) </span><span class="s0">for </span><span class="s1">x </span><span class="s0">in </span><span class="s1">argvalues</span>
        <span class="s1">]</span>

    <span class="s1">@classmethod</span>
    <span class="s0">def </span><span class="s1">_for_parametrize(</span>
        <span class="s1">cls</span><span class="s0">,</span>
        <span class="s1">argnames: Union[str</span><span class="s0">, </span><span class="s1">List[str]</span><span class="s0">, </span><span class="s1">Tuple[str</span><span class="s0">, </span><span class="s1">...]]</span><span class="s0">,</span>
        <span class="s1">argvalues: Iterable[Union[</span><span class="s2">&quot;ParameterSet&quot;</span><span class="s0">, </span><span class="s1">Sequence[object]</span><span class="s0">, </span><span class="s1">object]]</span><span class="s0">,</span>
        <span class="s1">func</span><span class="s0">,</span>
        <span class="s1">config: Config</span><span class="s0">,</span>
        <span class="s1">nodeid: str</span><span class="s0">,</span>
    <span class="s1">) -&gt; Tuple[Union[List[str]</span><span class="s0">, </span><span class="s1">Tuple[str</span><span class="s0">, </span><span class="s1">...]]</span><span class="s0">, </span><span class="s1">List[</span><span class="s2">&quot;ParameterSet&quot;</span><span class="s1">]]:</span>
        <span class="s1">argnames</span><span class="s0">, </span><span class="s1">force_tuple = cls._parse_parametrize_args(argnames</span><span class="s0">, </span><span class="s1">argvalues)</span>
        <span class="s1">parameters = cls._parse_parametrize_parameters(argvalues</span><span class="s0">, </span><span class="s1">force_tuple)</span>
        <span class="s0">del </span><span class="s1">argvalues</span>

        <span class="s0">if </span><span class="s1">parameters:</span>
            <span class="s5"># Check all parameter sets have the correct number of values.</span>
            <span class="s0">for </span><span class="s1">param </span><span class="s0">in </span><span class="s1">parameters:</span>
                <span class="s0">if </span><span class="s1">len(param.values) != len(argnames):</span>
                    <span class="s1">msg = (</span>
                        <span class="s2">'{nodeid}: in &quot;parametrize&quot; the number of names ({names_len}):</span><span class="s0">\n</span><span class="s2">'</span>
                        <span class="s2">&quot;  {names}</span><span class="s0">\n</span><span class="s2">&quot;</span>
                        <span class="s2">&quot;must be equal to the number of values ({values_len}):</span><span class="s0">\n</span><span class="s2">&quot;</span>
                        <span class="s2">&quot;  {values}&quot;</span>
                    <span class="s1">)</span>
                    <span class="s1">fail(</span>
                        <span class="s1">msg.format(</span>
                            <span class="s1">nodeid=nodeid</span><span class="s0">,</span>
                            <span class="s1">values=param.values</span><span class="s0">,</span>
                            <span class="s1">names=argnames</span><span class="s0">,</span>
                            <span class="s1">names_len=len(argnames)</span><span class="s0">,</span>
                            <span class="s1">values_len=len(param.values)</span><span class="s0">,</span>
                        <span class="s1">)</span><span class="s0">,</span>
                        <span class="s1">pytrace=</span><span class="s0">False,</span>
                    <span class="s1">)</span>
        <span class="s0">else</span><span class="s1">:</span>
            <span class="s5"># Empty parameter set (likely computed at runtime): create a single</span>
            <span class="s5"># parameter set with NOTSET values, with the &quot;empty parameter set&quot; mark applied to it.</span>
            <span class="s1">mark = get_empty_parameterset_mark(config</span><span class="s0">, </span><span class="s1">argnames</span><span class="s0">, </span><span class="s1">func)</span>
            <span class="s1">parameters.append(</span>
                <span class="s1">ParameterSet(values=(NOTSET</span><span class="s0">,</span><span class="s1">) * len(argnames)</span><span class="s0">, </span><span class="s1">marks=[mark]</span><span class="s0">, </span><span class="s1">id=</span><span class="s0">None</span><span class="s1">)</span>
            <span class="s1">)</span>
        <span class="s0">return </span><span class="s1">argnames</span><span class="s0">, </span><span class="s1">parameters</span>


<span class="s1">@final</span>
<span class="s1">@attr.s(frozen=</span><span class="s0">True, </span><span class="s1">init=</span><span class="s0">False, </span><span class="s1">auto_attribs=</span><span class="s0">True</span><span class="s1">)</span>
<span class="s0">class </span><span class="s1">Mark:</span>
    <span class="s5">#: Name of the mark.</span>
    <span class="s1">name: str</span>
    <span class="s5">#: Positional arguments of the mark decorator.</span>
    <span class="s1">args: Tuple[Any</span><span class="s0">, </span><span class="s1">...]</span>
    <span class="s5">#: Keyword arguments of the mark decorator.</span>
    <span class="s1">kwargs: Mapping[str</span><span class="s0">, </span><span class="s1">Any]</span>

    <span class="s5">#: Source Mark for ids with parametrize Marks.</span>
    <span class="s1">_param_ids_from: Optional[</span><span class="s2">&quot;Mark&quot;</span><span class="s1">] = attr.ib(default=</span><span class="s0">None, </span><span class="s1">repr=</span><span class="s0">False</span><span class="s1">)</span>
    <span class="s5">#: Resolved/generated ids with parametrize Marks.</span>
    <span class="s1">_param_ids_generated: Optional[Sequence[str]] = attr.ib(default=</span><span class="s0">None, </span><span class="s1">repr=</span><span class="s0">False</span><span class="s1">)</span>

    <span class="s0">def </span><span class="s1">__init__(</span>
        <span class="s1">self</span><span class="s0">,</span>
        <span class="s1">name: str</span><span class="s0">,</span>
        <span class="s1">args: Tuple[Any</span><span class="s0">, </span><span class="s1">...]</span><span class="s0">,</span>
        <span class="s1">kwargs: Mapping[str</span><span class="s0">, </span><span class="s1">Any]</span><span class="s0">,</span>
        <span class="s1">param_ids_from: Optional[</span><span class="s2">&quot;Mark&quot;</span><span class="s1">] = </span><span class="s0">None,</span>
        <span class="s1">param_ids_generated: Optional[Sequence[str]] = </span><span class="s0">None,</span>
        <span class="s1">*</span><span class="s0">,</span>
        <span class="s1">_ispytest: bool = </span><span class="s0">False,</span>
    <span class="s1">) -&gt; </span><span class="s0">None</span><span class="s1">:</span>
        <span class="s4">&quot;&quot;&quot;:meta private:&quot;&quot;&quot;</span>
        <span class="s1">check_ispytest(_ispytest)</span>
        <span class="s5"># Weirdness to bypass frozen=True.</span>
        <span class="s1">object.__setattr__(self</span><span class="s0">, </span><span class="s2">&quot;name&quot;</span><span class="s0">, </span><span class="s1">name)</span>
        <span class="s1">object.__setattr__(self</span><span class="s0">, </span><span class="s2">&quot;args&quot;</span><span class="s0">, </span><span class="s1">args)</span>
        <span class="s1">object.__setattr__(self</span><span class="s0">, </span><span class="s2">&quot;kwargs&quot;</span><span class="s0">, </span><span class="s1">kwargs)</span>
        <span class="s1">object.__setattr__(self</span><span class="s0">, </span><span class="s2">&quot;_param_ids_from&quot;</span><span class="s0">, </span><span class="s1">param_ids_from)</span>
        <span class="s1">object.__setattr__(self</span><span class="s0">, </span><span class="s2">&quot;_param_ids_generated&quot;</span><span class="s0">, </span><span class="s1">param_ids_generated)</span>

    <span class="s0">def </span><span class="s1">_has_param_ids(self) -&gt; bool:</span>
        <span class="s0">return </span><span class="s2">&quot;ids&quot; </span><span class="s0">in </span><span class="s1">self.kwargs </span><span class="s0">or </span><span class="s1">len(self.args) &gt;= </span><span class="s3">4</span>

    <span class="s0">def </span><span class="s1">combined_with(self</span><span class="s0">, </span><span class="s1">other: </span><span class="s2">&quot;Mark&quot;</span><span class="s1">) -&gt; </span><span class="s2">&quot;Mark&quot;</span><span class="s1">:</span>
        <span class="s4">&quot;&quot;&quot;Return a new Mark which is a combination of this 
        Mark and another Mark. 
 
        Combines by appending args and merging kwargs. 
 
        :param Mark other: The mark to combine with. 
        :rtype: Mark 
        &quot;&quot;&quot;</span>
        <span class="s0">assert </span><span class="s1">self.name == other.name</span>

        <span class="s5"># Remember source of ids with parametrize Marks.</span>
        <span class="s1">param_ids_from: Optional[Mark] = </span><span class="s0">None</span>
        <span class="s0">if </span><span class="s1">self.name == </span><span class="s2">&quot;parametrize&quot;</span><span class="s1">:</span>
            <span class="s0">if </span><span class="s1">other._has_param_ids():</span>
                <span class="s1">param_ids_from = other</span>
            <span class="s0">elif </span><span class="s1">self._has_param_ids():</span>
                <span class="s1">param_ids_from = self</span>

        <span class="s0">return </span><span class="s1">Mark(</span>
            <span class="s1">self.name</span><span class="s0">,</span>
            <span class="s1">self.args + other.args</span><span class="s0">,</span>
            <span class="s1">dict(self.kwargs</span><span class="s0">, </span><span class="s1">**other.kwargs)</span><span class="s0">,</span>
            <span class="s1">param_ids_from=param_ids_from</span><span class="s0">,</span>
            <span class="s1">_ispytest=</span><span class="s0">True,</span>
        <span class="s1">)</span>


<span class="s5"># A generic parameter designating an object to which a Mark may</span>
<span class="s5"># be applied -- a test function (callable) or class.</span>
<span class="s5"># Note: a lambda is not allowed, but this can't be represented.</span>
<span class="s1">Markable = TypeVar(</span><span class="s2">&quot;Markable&quot;</span><span class="s0">, </span><span class="s1">bound=Union[Callable[...</span><span class="s0">, </span><span class="s1">object]</span><span class="s0">, </span><span class="s1">type])</span>


<span class="s1">@attr.s(init=</span><span class="s0">False, </span><span class="s1">auto_attribs=</span><span class="s0">True</span><span class="s1">)</span>
<span class="s0">class </span><span class="s1">MarkDecorator:</span>
    <span class="s4">&quot;&quot;&quot;A decorator for applying a mark on test functions and classes. 
 
    ``MarkDecorators`` are created with ``pytest.mark``:: 
 
        mark1 = pytest.mark.NAME              # Simple MarkDecorator 
        mark2 = pytest.mark.NAME(name1=value) # Parametrized MarkDecorator 
 
    and can then be applied as decorators to test functions:: 
 
        @mark2 
        def test_function(): 
            pass 
 
    When a ``MarkDecorator`` is called, it does the following: 
 
    1. If called with a single class as its only positional argument and no 
       additional keyword arguments, it attaches the mark to the class so it 
       gets applied automatically to all test cases found in that class. 
 
    2. If called with a single function as its only positional argument and 
       no additional keyword arguments, it attaches the mark to the function, 
       containing all the arguments already stored internally in the 
       ``MarkDecorator``. 
 
    3. When called in any other case, it returns a new ``MarkDecorator`` 
       instance with the original ``MarkDecorator``'s content updated with 
       the arguments passed to this call. 
 
    Note: The rules above prevent a ``MarkDecorator`` from storing only a 
    single function or class reference as its positional argument with no 
    additional keyword or positional arguments. You can work around this by 
    using `with_args()`. 
    &quot;&quot;&quot;</span>

    <span class="s1">mark: Mark</span>

    <span class="s0">def </span><span class="s1">__init__(self</span><span class="s0">, </span><span class="s1">mark: Mark</span><span class="s0">, </span><span class="s1">*</span><span class="s0">, </span><span class="s1">_ispytest: bool = </span><span class="s0">False</span><span class="s1">) -&gt; </span><span class="s0">None</span><span class="s1">:</span>
        <span class="s4">&quot;&quot;&quot;:meta private:&quot;&quot;&quot;</span>
        <span class="s1">check_ispytest(_ispytest)</span>
        <span class="s1">self.mark = mark</span>

    <span class="s1">@property</span>
    <span class="s0">def </span><span class="s1">name(self) -&gt; str:</span>
        <span class="s4">&quot;&quot;&quot;Alias for mark.name.&quot;&quot;&quot;</span>
        <span class="s0">return </span><span class="s1">self.mark.name</span>

    <span class="s1">@property</span>
    <span class="s0">def </span><span class="s1">args(self) -&gt; Tuple[Any</span><span class="s0">, </span><span class="s1">...]:</span>
        <span class="s4">&quot;&quot;&quot;Alias for mark.args.&quot;&quot;&quot;</span>
        <span class="s0">return </span><span class="s1">self.mark.args</span>

    <span class="s1">@property</span>
    <span class="s0">def </span><span class="s1">kwargs(self) -&gt; Mapping[str</span><span class="s0">, </span><span class="s1">Any]:</span>
        <span class="s4">&quot;&quot;&quot;Alias for mark.kwargs.&quot;&quot;&quot;</span>
        <span class="s0">return </span><span class="s1">self.mark.kwargs</span>

    <span class="s1">@property</span>
    <span class="s0">def </span><span class="s1">markname(self) -&gt; str:</span>
        <span class="s4">&quot;&quot;&quot;:meta private:&quot;&quot;&quot;</span>
        <span class="s0">return </span><span class="s1">self.name  </span><span class="s5"># for backward-compat (2.4.1 had this attr)</span>

    <span class="s0">def </span><span class="s1">with_args(self</span><span class="s0">, </span><span class="s1">*args: object</span><span class="s0">, </span><span class="s1">**kwargs: object) -&gt; </span><span class="s2">&quot;MarkDecorator&quot;</span><span class="s1">:</span>
        <span class="s4">&quot;&quot;&quot;Return a MarkDecorator with extra arguments added. 
 
        Unlike calling the MarkDecorator, with_args() can be used even 
        if the sole argument is a callable/class. 
        &quot;&quot;&quot;</span>
        <span class="s1">mark = Mark(self.name</span><span class="s0">, </span><span class="s1">args</span><span class="s0">, </span><span class="s1">kwargs</span><span class="s0">, </span><span class="s1">_ispytest=</span><span class="s0">True</span><span class="s1">)</span>
        <span class="s0">return </span><span class="s1">MarkDecorator(self.mark.combined_with(mark)</span><span class="s0">, </span><span class="s1">_ispytest=</span><span class="s0">True</span><span class="s1">)</span>

    <span class="s5"># Type ignored because the overloads overlap with an incompatible</span>
    <span class="s5"># return type. Not much we can do about that. Thankfully mypy picks</span>
    <span class="s5"># the first match so it works out even if we break the rules.</span>
    <span class="s1">@overload</span>
    <span class="s0">def </span><span class="s1">__call__(self</span><span class="s0">, </span><span class="s1">arg: Markable) -&gt; Markable:  </span><span class="s5"># type: ignore[misc]</span>
        <span class="s0">pass</span>

    <span class="s1">@overload</span>
    <span class="s0">def </span><span class="s1">__call__(self</span><span class="s0">, </span><span class="s1">*args: object</span><span class="s0">, </span><span class="s1">**kwargs: object) -&gt; </span><span class="s2">&quot;MarkDecorator&quot;</span><span class="s1">:</span>
        <span class="s0">pass</span>

    <span class="s0">def </span><span class="s1">__call__(self</span><span class="s0">, </span><span class="s1">*args: object</span><span class="s0">, </span><span class="s1">**kwargs: object):</span>
        <span class="s4">&quot;&quot;&quot;Call the MarkDecorator.&quot;&quot;&quot;</span>
        <span class="s0">if </span><span class="s1">args </span><span class="s0">and not </span><span class="s1">kwargs:</span>
            <span class="s1">func = args[</span><span class="s3">0</span><span class="s1">]</span>
            <span class="s1">is_class = inspect.isclass(func)</span>
            <span class="s0">if </span><span class="s1">len(args) == </span><span class="s3">1 </span><span class="s0">and </span><span class="s1">(istestfunc(func) </span><span class="s0">or </span><span class="s1">is_class):</span>
                <span class="s1">store_mark(func</span><span class="s0">, </span><span class="s1">self.mark)</span>
                <span class="s0">return </span><span class="s1">func</span>
        <span class="s0">return </span><span class="s1">self.with_args(*args</span><span class="s0">, </span><span class="s1">**kwargs)</span>


<span class="s0">def </span><span class="s1">get_unpacked_marks(obj: object) -&gt; Iterable[Mark]:</span>
    <span class="s4">&quot;&quot;&quot;Obtain the unpacked marks that are stored on an object.&quot;&quot;&quot;</span>
    <span class="s1">mark_list = getattr(obj</span><span class="s0">, </span><span class="s2">&quot;pytestmark&quot;</span><span class="s0">, </span><span class="s1">[])</span>
    <span class="s0">if not </span><span class="s1">isinstance(mark_list</span><span class="s0">, </span><span class="s1">list):</span>
        <span class="s1">mark_list = [mark_list]</span>
    <span class="s0">return </span><span class="s1">normalize_mark_list(mark_list)</span>


<span class="s0">def </span><span class="s1">normalize_mark_list(</span>
    <span class="s1">mark_list: Iterable[Union[Mark</span><span class="s0">, </span><span class="s1">MarkDecorator]]</span>
<span class="s1">) -&gt; Iterable[Mark]:</span>
    <span class="s4">&quot;&quot;&quot; 
    Normalize an iterable of Mark or MarkDecorator objects into a list of marks 
    by retrieving the `mark` attribute on MarkDecorator instances. 
 
    :param mark_list: marks to normalize 
    :returns: A new list of the extracted Mark objects 
    &quot;&quot;&quot;</span>
    <span class="s0">for </span><span class="s1">mark </span><span class="s0">in </span><span class="s1">mark_list:</span>
        <span class="s1">mark_obj = getattr(mark</span><span class="s0">, </span><span class="s2">&quot;mark&quot;</span><span class="s0">, </span><span class="s1">mark)</span>
        <span class="s0">if not </span><span class="s1">isinstance(mark_obj</span><span class="s0">, </span><span class="s1">Mark):</span>
            <span class="s0">raise </span><span class="s1">TypeError(</span><span class="s2">f&quot;got </span><span class="s0">{</span><span class="s1">repr(mark_obj)</span><span class="s0">} </span><span class="s2">instead of Mark&quot;</span><span class="s1">)</span>
        <span class="s0">yield </span><span class="s1">mark_obj</span>


<span class="s0">def </span><span class="s1">store_mark(obj</span><span class="s0">, </span><span class="s1">mark: Mark) -&gt; </span><span class="s0">None</span><span class="s1">:</span>
    <span class="s4">&quot;&quot;&quot;Store a Mark on an object. 
 
    This is used to implement the Mark declarations/decorators correctly. 
    &quot;&quot;&quot;</span>
    <span class="s0">assert </span><span class="s1">isinstance(mark</span><span class="s0">, </span><span class="s1">Mark)</span><span class="s0">, </span><span class="s1">mark</span>
    <span class="s5"># Always reassign name to avoid updating pytestmark in a reference that</span>
    <span class="s5"># was only borrowed.</span>
    <span class="s1">obj.pytestmark = [*get_unpacked_marks(obj)</span><span class="s0">, </span><span class="s1">mark]</span>


<span class="s5"># Typing for builtin pytest marks. This is cheating; it gives builtin marks</span>
<span class="s5"># special privilege, and breaks modularity. But practicality beats purity...</span>
<span class="s0">if </span><span class="s1">TYPE_CHECKING:</span>
    <span class="s0">from </span><span class="s1">_pytest.scope </span><span class="s0">import </span><span class="s1">_ScopeName</span>

    <span class="s0">class </span><span class="s1">_SkipMarkDecorator(MarkDecorator):</span>
        <span class="s1">@overload  </span><span class="s5"># type: ignore[override,misc]</span>
        <span class="s0">def </span><span class="s1">__call__(self</span><span class="s0">, </span><span class="s1">arg: Markable) -&gt; Markable:</span>
            <span class="s1">...</span>

        <span class="s1">@overload</span>
        <span class="s0">def </span><span class="s1">__call__(self</span><span class="s0">, </span><span class="s1">reason: str = ...) -&gt; </span><span class="s2">&quot;MarkDecorator&quot;</span><span class="s1">:</span>
            <span class="s1">...</span>

    <span class="s0">class </span><span class="s1">_SkipifMarkDecorator(MarkDecorator):</span>
        <span class="s0">def </span><span class="s1">__call__(  </span><span class="s5"># type: ignore[override]</span>
            <span class="s1">self</span><span class="s0">,</span>
            <span class="s1">condition: Union[str</span><span class="s0">, </span><span class="s1">bool] = ...</span><span class="s0">,</span>
            <span class="s1">*conditions: Union[str</span><span class="s0">, </span><span class="s1">bool]</span><span class="s0">,</span>
            <span class="s1">reason: str = ...</span><span class="s0">,</span>
        <span class="s1">) -&gt; MarkDecorator:</span>
            <span class="s1">...</span>

    <span class="s0">class </span><span class="s1">_XfailMarkDecorator(MarkDecorator):</span>
        <span class="s1">@overload  </span><span class="s5"># type: ignore[override,misc]</span>
        <span class="s0">def </span><span class="s1">__call__(self</span><span class="s0">, </span><span class="s1">arg: Markable) -&gt; Markable:</span>
            <span class="s1">...</span>

        <span class="s1">@overload</span>
        <span class="s0">def </span><span class="s1">__call__(</span>
            <span class="s1">self</span><span class="s0">,</span>
            <span class="s1">condition: Union[str</span><span class="s0">, </span><span class="s1">bool] = ...</span><span class="s0">,</span>
            <span class="s1">*conditions: Union[str</span><span class="s0">, </span><span class="s1">bool]</span><span class="s0">,</span>
            <span class="s1">reason: str = ...</span><span class="s0">,</span>
            <span class="s1">run: bool = ...</span><span class="s0">,</span>
            <span class="s1">raises: Union[Type[BaseException]</span><span class="s0">, </span><span class="s1">Tuple[Type[BaseException]</span><span class="s0">, </span><span class="s1">...]] = ...</span><span class="s0">,</span>
            <span class="s1">strict: bool = ...</span><span class="s0">,</span>
        <span class="s1">) -&gt; MarkDecorator:</span>
            <span class="s1">...</span>

    <span class="s0">class </span><span class="s1">_ParametrizeMarkDecorator(MarkDecorator):</span>
        <span class="s0">def </span><span class="s1">__call__(  </span><span class="s5"># type: ignore[override]</span>
            <span class="s1">self</span><span class="s0">,</span>
            <span class="s1">argnames: Union[str</span><span class="s0">, </span><span class="s1">List[str]</span><span class="s0">, </span><span class="s1">Tuple[str</span><span class="s0">, </span><span class="s1">...]]</span><span class="s0">,</span>
            <span class="s1">argvalues: Iterable[Union[ParameterSet</span><span class="s0">, </span><span class="s1">Sequence[object]</span><span class="s0">, </span><span class="s1">object]]</span><span class="s0">,</span>
            <span class="s1">*</span><span class="s0">,</span>
            <span class="s1">indirect: Union[bool</span><span class="s0">, </span><span class="s1">Sequence[str]] = ...</span><span class="s0">,</span>
            <span class="s1">ids: Optional[</span>
                <span class="s1">Union[</span>
                    <span class="s1">Iterable[Union[</span><span class="s0">None, </span><span class="s1">str</span><span class="s0">, </span><span class="s1">float</span><span class="s0">, </span><span class="s1">int</span><span class="s0">, </span><span class="s1">bool]]</span><span class="s0">,</span>
                    <span class="s1">Callable[[Any]</span><span class="s0">, </span><span class="s1">Optional[object]]</span><span class="s0">,</span>
                <span class="s1">]</span>
            <span class="s1">] = ...</span><span class="s0">,</span>
            <span class="s1">scope: Optional[_ScopeName] = ...</span><span class="s0">,</span>
        <span class="s1">) -&gt; MarkDecorator:</span>
            <span class="s1">...</span>

    <span class="s0">class </span><span class="s1">_UsefixturesMarkDecorator(MarkDecorator):</span>
        <span class="s0">def </span><span class="s1">__call__(self</span><span class="s0">, </span><span class="s1">*fixtures: str) -&gt; MarkDecorator:  </span><span class="s5"># type: ignore[override]</span>
            <span class="s1">...</span>

    <span class="s0">class </span><span class="s1">_FilterwarningsMarkDecorator(MarkDecorator):</span>
        <span class="s0">def </span><span class="s1">__call__(self</span><span class="s0">, </span><span class="s1">*filters: str) -&gt; MarkDecorator:  </span><span class="s5"># type: ignore[override]</span>
            <span class="s1">...</span>


<span class="s1">@final</span>
<span class="s0">class </span><span class="s1">MarkGenerator:</span>
    <span class="s4">&quot;&quot;&quot;Factory for :class:`MarkDecorator` objects - exposed as 
    a ``pytest.mark`` singleton instance. 
 
    Example:: 
 
         import pytest 
 
         @pytest.mark.slowtest 
         def test_function(): 
            pass 
 
    applies a 'slowtest' :class:`Mark` on ``test_function``. 
    &quot;&quot;&quot;</span>

    <span class="s5"># See TYPE_CHECKING above.</span>
    <span class="s0">if </span><span class="s1">TYPE_CHECKING:</span>
        <span class="s1">skip: _SkipMarkDecorator</span>
        <span class="s1">skipif: _SkipifMarkDecorator</span>
        <span class="s1">xfail: _XfailMarkDecorator</span>
        <span class="s1">parametrize: _ParametrizeMarkDecorator</span>
        <span class="s1">usefixtures: _UsefixturesMarkDecorator</span>
        <span class="s1">filterwarnings: _FilterwarningsMarkDecorator</span>

    <span class="s0">def </span><span class="s1">__init__(self</span><span class="s0">, </span><span class="s1">*</span><span class="s0">, </span><span class="s1">_ispytest: bool = </span><span class="s0">False</span><span class="s1">) -&gt; </span><span class="s0">None</span><span class="s1">:</span>
        <span class="s1">check_ispytest(_ispytest)</span>
        <span class="s1">self._config: Optional[Config] = </span><span class="s0">None</span>
        <span class="s1">self._markers: Set[str] = set()</span>

    <span class="s0">def </span><span class="s1">__getattr__(self</span><span class="s0">, </span><span class="s1">name: str) -&gt; MarkDecorator:</span>
        <span class="s4">&quot;&quot;&quot;Generate a new :class:`MarkDecorator` with the given name.&quot;&quot;&quot;</span>
        <span class="s0">if </span><span class="s1">name[</span><span class="s3">0</span><span class="s1">] == </span><span class="s2">&quot;_&quot;</span><span class="s1">:</span>
            <span class="s0">raise </span><span class="s1">AttributeError(</span><span class="s2">&quot;Marker name must NOT start with underscore&quot;</span><span class="s1">)</span>

        <span class="s0">if </span><span class="s1">self._config </span><span class="s0">is not None</span><span class="s1">:</span>
            <span class="s5"># We store a set of markers as a performance optimisation - if a mark</span>
            <span class="s5"># name is in the set we definitely know it, but a mark may be known and</span>
            <span class="s5"># not in the set.  We therefore start by updating the set!</span>
            <span class="s0">if </span><span class="s1">name </span><span class="s0">not in </span><span class="s1">self._markers:</span>
                <span class="s0">for </span><span class="s1">line </span><span class="s0">in </span><span class="s1">self._config.getini(</span><span class="s2">&quot;markers&quot;</span><span class="s1">):</span>
                    <span class="s5"># example lines: &quot;skipif(condition): skip the given test if...&quot;</span>
                    <span class="s5"># or &quot;hypothesis: tests which use Hypothesis&quot;, so to get the</span>
                    <span class="s5"># marker name we split on both `:` and `(`.</span>
                    <span class="s1">marker = line.split(</span><span class="s2">&quot;:&quot;</span><span class="s1">)[</span><span class="s3">0</span><span class="s1">].split(</span><span class="s2">&quot;(&quot;</span><span class="s1">)[</span><span class="s3">0</span><span class="s1">].strip()</span>
                    <span class="s1">self._markers.add(marker)</span>

            <span class="s5"># If the name is not in the set of known marks after updating,</span>
            <span class="s5"># then it really is time to issue a warning or an error.</span>
            <span class="s0">if </span><span class="s1">name </span><span class="s0">not in </span><span class="s1">self._markers:</span>
                <span class="s0">if </span><span class="s1">self._config.option.strict_markers </span><span class="s0">or </span><span class="s1">self._config.option.strict:</span>
                    <span class="s1">fail(</span>
                        <span class="s2">f&quot;</span><span class="s0">{</span><span class="s1">name</span><span class="s0">!r} </span><span class="s2">not found in `markers` configuration option&quot;</span><span class="s0">,</span>
                        <span class="s1">pytrace=</span><span class="s0">False,</span>
                    <span class="s1">)</span>

                <span class="s5"># Raise a specific error for common misspellings of &quot;parametrize&quot;.</span>
                <span class="s0">if </span><span class="s1">name </span><span class="s0">in </span><span class="s1">[</span><span class="s2">&quot;parameterize&quot;</span><span class="s0">, </span><span class="s2">&quot;parametrise&quot;</span><span class="s0">, </span><span class="s2">&quot;parameterise&quot;</span><span class="s1">]:</span>
                    <span class="s1">__tracebackhide__ = </span><span class="s0">True</span>
                    <span class="s1">fail(</span><span class="s2">f&quot;Unknown '</span><span class="s0">{</span><span class="s1">name</span><span class="s0">}</span><span class="s2">' mark, did you mean 'parametrize'?&quot;</span><span class="s1">)</span>

                <span class="s1">warnings.warn(</span>
                    <span class="s2">&quot;Unknown pytest.mark.%s - is this a typo?  You can register &quot;</span>
                    <span class="s2">&quot;custom marks to avoid this warning - for details, see &quot;</span>
                    <span class="s2">&quot;https://docs.pytest.org/en/stable/how-to/mark.html&quot; </span><span class="s1">% name</span><span class="s0">,</span>
                    <span class="s1">PytestUnknownMarkWarning</span><span class="s0">,</span>
                    <span class="s3">2</span><span class="s0">,</span>
                <span class="s1">)</span>

        <span class="s0">return </span><span class="s1">MarkDecorator(Mark(name</span><span class="s0">, </span><span class="s1">()</span><span class="s0">, </span><span class="s1">{}</span><span class="s0">, </span><span class="s1">_ispytest=</span><span class="s0">True</span><span class="s1">)</span><span class="s0">, </span><span class="s1">_ispytest=</span><span class="s0">True</span><span class="s1">)</span>


<span class="s1">MARK_GEN = MarkGenerator(_ispytest=</span><span class="s0">True</span><span class="s1">)</span>


<span class="s1">@final</span>
<span class="s0">class </span><span class="s1">NodeKeywords(MutableMapping[str</span><span class="s0">, </span><span class="s1">Any]):</span>
    <span class="s1">__slots__ = (</span><span class="s2">&quot;node&quot;</span><span class="s0">, </span><span class="s2">&quot;parent&quot;</span><span class="s0">, </span><span class="s2">&quot;_markers&quot;</span><span class="s1">)</span>

    <span class="s0">def </span><span class="s1">__init__(self</span><span class="s0">, </span><span class="s1">node: </span><span class="s2">&quot;Node&quot;</span><span class="s1">) -&gt; </span><span class="s0">None</span><span class="s1">:</span>
        <span class="s1">self.node = node</span>
        <span class="s1">self.parent = node.parent</span>
        <span class="s1">self._markers = {node.name: </span><span class="s0">True</span><span class="s1">}</span>

    <span class="s0">def </span><span class="s1">__getitem__(self</span><span class="s0">, </span><span class="s1">key: str) -&gt; Any:</span>
        <span class="s0">try</span><span class="s1">:</span>
            <span class="s0">return </span><span class="s1">self._markers[key]</span>
        <span class="s0">except </span><span class="s1">KeyError:</span>
            <span class="s0">if </span><span class="s1">self.parent </span><span class="s0">is None</span><span class="s1">:</span>
                <span class="s0">raise</span>
            <span class="s0">return </span><span class="s1">self.parent.keywords[key]</span>

    <span class="s0">def </span><span class="s1">__setitem__(self</span><span class="s0">, </span><span class="s1">key: str</span><span class="s0">, </span><span class="s1">value: Any) -&gt; </span><span class="s0">None</span><span class="s1">:</span>
        <span class="s1">self._markers[key] = value</span>

    <span class="s5"># Note: we could've avoided explicitly implementing some of the methods</span>
    <span class="s5"># below and use the collections.abc fallback, but that would be slow.</span>

    <span class="s0">def </span><span class="s1">__contains__(self</span><span class="s0">, </span><span class="s1">key: object) -&gt; bool:</span>
        <span class="s0">return </span><span class="s1">(</span>
            <span class="s1">key </span><span class="s0">in </span><span class="s1">self._markers</span>
            <span class="s0">or </span><span class="s1">self.parent </span><span class="s0">is not None</span>
            <span class="s0">and </span><span class="s1">key </span><span class="s0">in </span><span class="s1">self.parent.keywords</span>
        <span class="s1">)</span>

    <span class="s0">def </span><span class="s1">update(  </span><span class="s5"># type: ignore[override]</span>
        <span class="s1">self</span><span class="s0">,</span>
        <span class="s1">other: Union[Mapping[str</span><span class="s0">, </span><span class="s1">Any]</span><span class="s0">, </span><span class="s1">Iterable[Tuple[str</span><span class="s0">, </span><span class="s1">Any]]] = ()</span><span class="s0">,</span>
        <span class="s1">**kwds: Any</span><span class="s0">,</span>
    <span class="s1">) -&gt; </span><span class="s0">None</span><span class="s1">:</span>
        <span class="s1">self._markers.update(other)</span>
        <span class="s1">self._markers.update(kwds)</span>

    <span class="s0">def </span><span class="s1">__delitem__(self</span><span class="s0">, </span><span class="s1">key: str) -&gt; </span><span class="s0">None</span><span class="s1">:</span>
        <span class="s0">raise </span><span class="s1">ValueError(</span><span class="s2">&quot;cannot delete key in keywords dict&quot;</span><span class="s1">)</span>

    <span class="s0">def </span><span class="s1">__iter__(self) -&gt; Iterator[str]:</span>
        <span class="s5"># Doesn't need to be fast.</span>
        <span class="s0">yield from </span><span class="s1">self._markers</span>
        <span class="s0">if </span><span class="s1">self.parent </span><span class="s0">is not None</span><span class="s1">:</span>
            <span class="s0">for </span><span class="s1">keyword </span><span class="s0">in </span><span class="s1">self.parent.keywords:</span>
                <span class="s5"># self._marks and self.parent.keywords can have duplicates.</span>
                <span class="s0">if </span><span class="s1">keyword </span><span class="s0">not in </span><span class="s1">self._markers:</span>
                    <span class="s0">yield </span><span class="s1">keyword</span>

    <span class="s0">def </span><span class="s1">__len__(self) -&gt; int:</span>
        <span class="s5"># Doesn't need to be fast.</span>
        <span class="s0">return </span><span class="s1">sum(</span><span class="s3">1 </span><span class="s0">for </span><span class="s1">keyword </span><span class="s0">in </span><span class="s1">self)</span>

    <span class="s0">def </span><span class="s1">__repr__(self) -&gt; str:</span>
        <span class="s0">return </span><span class="s2">f&quot;&lt;NodeKeywords for node </span><span class="s0">{</span><span class="s1">self.node</span><span class="s0">}</span><span class="s2">&gt;&quot;</span>
</pre>
</body>
</html>