<html>
<head>
<title>python.py</title>
<meta http-equiv="Content-Type" content="text/html; charset=utf-8">
<style type="text/css">
.s0 { color: #629755; font-style: italic;}
.s1 { color: #a9b7c6;}
.s2 { color: #cc7832;}
.s3 { color: #6a8759;}
.s4 { color: #808080;}
.s5 { color: #6897bb;}
</style>
</head>
<body bgcolor="#2b2b2b">
<table CELLSPACING=0 CELLPADDING=5 COLS=1 WIDTH="100%" BGCOLOR="#606060" >
<tr><td><center>
<font face="Arial, Helvetica" color="#000000">
python.py</font>
</center></td></tr></table>
<pre><span class="s0">&quot;&quot;&quot;Python test discovery, setup and run of test functions.&quot;&quot;&quot;</span>
<span class="s2">import </span><span class="s1">enum</span>
<span class="s2">import </span><span class="s1">fnmatch</span>
<span class="s2">import </span><span class="s1">inspect</span>
<span class="s2">import </span><span class="s1">itertools</span>
<span class="s2">import </span><span class="s1">os</span>
<span class="s2">import </span><span class="s1">sys</span>
<span class="s2">import </span><span class="s1">types</span>
<span class="s2">import </span><span class="s1">warnings</span>
<span class="s2">from </span><span class="s1">collections </span><span class="s2">import </span><span class="s1">Counter</span>
<span class="s2">from </span><span class="s1">collections </span><span class="s2">import </span><span class="s1">defaultdict</span>
<span class="s2">from </span><span class="s1">functools </span><span class="s2">import </span><span class="s1">partial</span>
<span class="s2">from </span><span class="s1">pathlib </span><span class="s2">import </span><span class="s1">Path</span>
<span class="s2">from </span><span class="s1">typing </span><span class="s2">import </span><span class="s1">Any</span>
<span class="s2">from </span><span class="s1">typing </span><span class="s2">import </span><span class="s1">Callable</span>
<span class="s2">from </span><span class="s1">typing </span><span class="s2">import </span><span class="s1">Dict</span>
<span class="s2">from </span><span class="s1">typing </span><span class="s2">import </span><span class="s1">Generator</span>
<span class="s2">from </span><span class="s1">typing </span><span class="s2">import </span><span class="s1">Iterable</span>
<span class="s2">from </span><span class="s1">typing </span><span class="s2">import </span><span class="s1">Iterator</span>
<span class="s2">from </span><span class="s1">typing </span><span class="s2">import </span><span class="s1">List</span>
<span class="s2">from </span><span class="s1">typing </span><span class="s2">import </span><span class="s1">Mapping</span>
<span class="s2">from </span><span class="s1">typing </span><span class="s2">import </span><span class="s1">Optional</span>
<span class="s2">from </span><span class="s1">typing </span><span class="s2">import </span><span class="s1">Pattern</span>
<span class="s2">from </span><span class="s1">typing </span><span class="s2">import </span><span class="s1">Sequence</span>
<span class="s2">from </span><span class="s1">typing </span><span class="s2">import </span><span class="s1">Set</span>
<span class="s2">from </span><span class="s1">typing </span><span class="s2">import </span><span class="s1">Tuple</span>
<span class="s2">from </span><span class="s1">typing </span><span class="s2">import </span><span class="s1">TYPE_CHECKING</span>
<span class="s2">from </span><span class="s1">typing </span><span class="s2">import </span><span class="s1">Union</span>

<span class="s2">import </span><span class="s1">attr</span>

<span class="s2">import </span><span class="s1">_pytest</span>
<span class="s2">from </span><span class="s1">_pytest </span><span class="s2">import </span><span class="s1">fixtures</span>
<span class="s2">from </span><span class="s1">_pytest </span><span class="s2">import </span><span class="s1">nodes</span>
<span class="s2">from </span><span class="s1">_pytest._code </span><span class="s2">import </span><span class="s1">filter_traceback</span>
<span class="s2">from </span><span class="s1">_pytest._code </span><span class="s2">import </span><span class="s1">getfslineno</span>
<span class="s2">from </span><span class="s1">_pytest._code.code </span><span class="s2">import </span><span class="s1">ExceptionInfo</span>
<span class="s2">from </span><span class="s1">_pytest._code.code </span><span class="s2">import </span><span class="s1">TerminalRepr</span>
<span class="s2">from </span><span class="s1">_pytest._io </span><span class="s2">import </span><span class="s1">TerminalWriter</span>
<span class="s2">from </span><span class="s1">_pytest._io.saferepr </span><span class="s2">import </span><span class="s1">saferepr</span>
<span class="s2">from </span><span class="s1">_pytest.compat </span><span class="s2">import </span><span class="s1">ascii_escaped</span>
<span class="s2">from </span><span class="s1">_pytest.compat </span><span class="s2">import </span><span class="s1">assert_never</span>
<span class="s2">from </span><span class="s1">_pytest.compat </span><span class="s2">import </span><span class="s1">final</span>
<span class="s2">from </span><span class="s1">_pytest.compat </span><span class="s2">import </span><span class="s1">get_default_arg_names</span>
<span class="s2">from </span><span class="s1">_pytest.compat </span><span class="s2">import </span><span class="s1">get_real_func</span>
<span class="s2">from </span><span class="s1">_pytest.compat </span><span class="s2">import </span><span class="s1">getimfunc</span>
<span class="s2">from </span><span class="s1">_pytest.compat </span><span class="s2">import </span><span class="s1">getlocation</span>
<span class="s2">from </span><span class="s1">_pytest.compat </span><span class="s2">import </span><span class="s1">is_async_function</span>
<span class="s2">from </span><span class="s1">_pytest.compat </span><span class="s2">import </span><span class="s1">is_generator</span>
<span class="s2">from </span><span class="s1">_pytest.compat </span><span class="s2">import </span><span class="s1">LEGACY_PATH</span>
<span class="s2">from </span><span class="s1">_pytest.compat </span><span class="s2">import </span><span class="s1">NOTSET</span>
<span class="s2">from </span><span class="s1">_pytest.compat </span><span class="s2">import </span><span class="s1">safe_getattr</span>
<span class="s2">from </span><span class="s1">_pytest.compat </span><span class="s2">import </span><span class="s1">safe_isclass</span>
<span class="s2">from </span><span class="s1">_pytest.compat </span><span class="s2">import </span><span class="s1">STRING_TYPES</span>
<span class="s2">from </span><span class="s1">_pytest.config </span><span class="s2">import </span><span class="s1">Config</span>
<span class="s2">from </span><span class="s1">_pytest.config </span><span class="s2">import </span><span class="s1">ExitCode</span>
<span class="s2">from </span><span class="s1">_pytest.config </span><span class="s2">import </span><span class="s1">hookimpl</span>
<span class="s2">from </span><span class="s1">_pytest.config.argparsing </span><span class="s2">import </span><span class="s1">Parser</span>
<span class="s2">from </span><span class="s1">_pytest.deprecated </span><span class="s2">import </span><span class="s1">check_ispytest</span>
<span class="s2">from </span><span class="s1">_pytest.deprecated </span><span class="s2">import </span><span class="s1">FSCOLLECTOR_GETHOOKPROXY_ISINITPATH</span>
<span class="s2">from </span><span class="s1">_pytest.deprecated </span><span class="s2">import </span><span class="s1">INSTANCE_COLLECTOR</span>
<span class="s2">from </span><span class="s1">_pytest.fixtures </span><span class="s2">import </span><span class="s1">FuncFixtureInfo</span>
<span class="s2">from </span><span class="s1">_pytest.main </span><span class="s2">import </span><span class="s1">Session</span>
<span class="s2">from </span><span class="s1">_pytest.mark </span><span class="s2">import </span><span class="s1">MARK_GEN</span>
<span class="s2">from </span><span class="s1">_pytest.mark </span><span class="s2">import </span><span class="s1">ParameterSet</span>
<span class="s2">from </span><span class="s1">_pytest.mark.structures </span><span class="s2">import </span><span class="s1">get_unpacked_marks</span>
<span class="s2">from </span><span class="s1">_pytest.mark.structures </span><span class="s2">import </span><span class="s1">Mark</span>
<span class="s2">from </span><span class="s1">_pytest.mark.structures </span><span class="s2">import </span><span class="s1">MarkDecorator</span>
<span class="s2">from </span><span class="s1">_pytest.mark.structures </span><span class="s2">import </span><span class="s1">normalize_mark_list</span>
<span class="s2">from </span><span class="s1">_pytest.outcomes </span><span class="s2">import </span><span class="s1">fail</span>
<span class="s2">from </span><span class="s1">_pytest.outcomes </span><span class="s2">import </span><span class="s1">skip</span>
<span class="s2">from </span><span class="s1">_pytest.pathlib </span><span class="s2">import </span><span class="s1">bestrelpath</span>
<span class="s2">from </span><span class="s1">_pytest.pathlib </span><span class="s2">import </span><span class="s1">fnmatch_ex</span>
<span class="s2">from </span><span class="s1">_pytest.pathlib </span><span class="s2">import </span><span class="s1">import_path</span>
<span class="s2">from </span><span class="s1">_pytest.pathlib </span><span class="s2">import </span><span class="s1">ImportPathMismatchError</span>
<span class="s2">from </span><span class="s1">_pytest.pathlib </span><span class="s2">import </span><span class="s1">parts</span>
<span class="s2">from </span><span class="s1">_pytest.pathlib </span><span class="s2">import </span><span class="s1">visit</span>
<span class="s2">from </span><span class="s1">_pytest.scope </span><span class="s2">import </span><span class="s1">Scope</span>
<span class="s2">from </span><span class="s1">_pytest.warning_types </span><span class="s2">import </span><span class="s1">PytestCollectionWarning</span>
<span class="s2">from </span><span class="s1">_pytest.warning_types </span><span class="s2">import </span><span class="s1">PytestUnhandledCoroutineWarning</span>

<span class="s2">if </span><span class="s1">TYPE_CHECKING:</span>
    <span class="s2">from </span><span class="s1">typing_extensions </span><span class="s2">import </span><span class="s1">Literal</span>
    <span class="s2">from </span><span class="s1">_pytest.scope </span><span class="s2">import </span><span class="s1">_ScopeName</span>


<span class="s1">_PYTEST_DIR = Path(_pytest.__file__).parent</span>


<span class="s2">def </span><span class="s1">pytest_addoption(parser: Parser) -&gt; </span><span class="s2">None</span><span class="s1">:</span>
    <span class="s1">group = parser.getgroup(</span><span class="s3">&quot;general&quot;</span><span class="s1">)</span>
    <span class="s1">group.addoption(</span>
        <span class="s3">&quot;--fixtures&quot;</span><span class="s2">,</span>
        <span class="s3">&quot;--funcargs&quot;</span><span class="s2">,</span>
        <span class="s1">action=</span><span class="s3">&quot;store_true&quot;</span><span class="s2">,</span>
        <span class="s1">dest=</span><span class="s3">&quot;showfixtures&quot;</span><span class="s2">,</span>
        <span class="s1">default=</span><span class="s2">False,</span>
        <span class="s1">help=</span><span class="s3">&quot;show available fixtures, sorted by plugin appearance &quot;</span>
        <span class="s3">&quot;(fixtures with leading '_' are only shown with '-v')&quot;</span><span class="s2">,</span>
    <span class="s1">)</span>
    <span class="s1">group.addoption(</span>
        <span class="s3">&quot;--fixtures-per-test&quot;</span><span class="s2">,</span>
        <span class="s1">action=</span><span class="s3">&quot;store_true&quot;</span><span class="s2">,</span>
        <span class="s1">dest=</span><span class="s3">&quot;show_fixtures_per_test&quot;</span><span class="s2">,</span>
        <span class="s1">default=</span><span class="s2">False,</span>
        <span class="s1">help=</span><span class="s3">&quot;show fixtures per test&quot;</span><span class="s2">,</span>
    <span class="s1">)</span>
    <span class="s1">parser.addini(</span>
        <span class="s3">&quot;python_files&quot;</span><span class="s2">,</span>
        <span class="s1">type=</span><span class="s3">&quot;args&quot;</span><span class="s2">,</span>
        <span class="s4"># NOTE: default is also used in AssertionRewritingHook.</span>
        <span class="s1">default=[</span><span class="s3">&quot;test_*.py&quot;</span><span class="s2">, </span><span class="s3">&quot;*_test.py&quot;</span><span class="s1">]</span><span class="s2">,</span>
        <span class="s1">help=</span><span class="s3">&quot;glob-style file patterns for Python test module discovery&quot;</span><span class="s2">,</span>
    <span class="s1">)</span>
    <span class="s1">parser.addini(</span>
        <span class="s3">&quot;python_classes&quot;</span><span class="s2">,</span>
        <span class="s1">type=</span><span class="s3">&quot;args&quot;</span><span class="s2">,</span>
        <span class="s1">default=[</span><span class="s3">&quot;Test&quot;</span><span class="s1">]</span><span class="s2">,</span>
        <span class="s1">help=</span><span class="s3">&quot;prefixes or glob names for Python test class discovery&quot;</span><span class="s2">,</span>
    <span class="s1">)</span>
    <span class="s1">parser.addini(</span>
        <span class="s3">&quot;python_functions&quot;</span><span class="s2">,</span>
        <span class="s1">type=</span><span class="s3">&quot;args&quot;</span><span class="s2">,</span>
        <span class="s1">default=[</span><span class="s3">&quot;test&quot;</span><span class="s1">]</span><span class="s2">,</span>
        <span class="s1">help=</span><span class="s3">&quot;prefixes or glob names for Python test function and method discovery&quot;</span><span class="s2">,</span>
    <span class="s1">)</span>
    <span class="s1">parser.addini(</span>
        <span class="s3">&quot;disable_test_id_escaping_and_forfeit_all_rights_to_community_support&quot;</span><span class="s2">,</span>
        <span class="s1">type=</span><span class="s3">&quot;bool&quot;</span><span class="s2">,</span>
        <span class="s1">default=</span><span class="s2">False,</span>
        <span class="s1">help=</span><span class="s3">&quot;disable string escape non-ascii characters, might cause unwanted &quot;</span>
        <span class="s3">&quot;side effects(use at your own risk)&quot;</span><span class="s2">,</span>
    <span class="s1">)</span>


<span class="s2">def </span><span class="s1">pytest_cmdline_main(config: Config) -&gt; Optional[Union[int</span><span class="s2">, </span><span class="s1">ExitCode]]:</span>
    <span class="s2">if </span><span class="s1">config.option.showfixtures:</span>
        <span class="s1">showfixtures(config)</span>
        <span class="s2">return </span><span class="s5">0</span>
    <span class="s2">if </span><span class="s1">config.option.show_fixtures_per_test:</span>
        <span class="s1">show_fixtures_per_test(config)</span>
        <span class="s2">return </span><span class="s5">0</span>
    <span class="s2">return None</span>


<span class="s2">def </span><span class="s1">pytest_generate_tests(metafunc: </span><span class="s3">&quot;Metafunc&quot;</span><span class="s1">) -&gt; </span><span class="s2">None</span><span class="s1">:</span>
    <span class="s2">for </span><span class="s1">marker </span><span class="s2">in </span><span class="s1">metafunc.definition.iter_markers(name=</span><span class="s3">&quot;parametrize&quot;</span><span class="s1">):</span>
        <span class="s1">metafunc.parametrize(*marker.args</span><span class="s2">, </span><span class="s1">**marker.kwargs</span><span class="s2">, </span><span class="s1">_param_mark=marker)</span>


<span class="s2">def </span><span class="s1">pytest_configure(config: Config) -&gt; </span><span class="s2">None</span><span class="s1">:</span>
    <span class="s1">config.addinivalue_line(</span>
        <span class="s3">&quot;markers&quot;</span><span class="s2">,</span>
        <span class="s3">&quot;parametrize(argnames, argvalues): call a test function multiple &quot;</span>
        <span class="s3">&quot;times passing in different arguments in turn. argvalues generally &quot;</span>
        <span class="s3">&quot;needs to be a list of values if argnames specifies only one name &quot;</span>
        <span class="s3">&quot;or a list of tuples of values if argnames specifies multiple names. &quot;</span>
        <span class="s3">&quot;Example: @parametrize('arg1', [1,2]) would lead to two calls of the &quot;</span>
        <span class="s3">&quot;decorated test function, one with arg1=1 and another with arg1=2.&quot;</span>
        <span class="s3">&quot;see https://docs.pytest.org/en/stable/how-to/parametrize.html for more info &quot;</span>
        <span class="s3">&quot;and examples.&quot;</span><span class="s2">,</span>
    <span class="s1">)</span>
    <span class="s1">config.addinivalue_line(</span>
        <span class="s3">&quot;markers&quot;</span><span class="s2">,</span>
        <span class="s3">&quot;usefixtures(fixturename1, fixturename2, ...): mark tests as needing &quot;</span>
        <span class="s3">&quot;all of the specified fixtures. see &quot;</span>
        <span class="s3">&quot;https://docs.pytest.org/en/stable/explanation/fixtures.html#usefixtures &quot;</span><span class="s2">,</span>
    <span class="s1">)</span>


<span class="s2">def </span><span class="s1">async_warn_and_skip(nodeid: str) -&gt; </span><span class="s2">None</span><span class="s1">:</span>
    <span class="s1">msg = </span><span class="s3">&quot;async def functions are not natively supported and have been skipped.</span><span class="s2">\n</span><span class="s3">&quot;</span>
    <span class="s1">msg += (</span>
        <span class="s3">&quot;You need to install a suitable plugin for your async framework, for example:</span><span class="s2">\n</span><span class="s3">&quot;</span>
    <span class="s1">)</span>
    <span class="s1">msg += </span><span class="s3">&quot;  - anyio</span><span class="s2">\n</span><span class="s3">&quot;</span>
    <span class="s1">msg += </span><span class="s3">&quot;  - pytest-asyncio</span><span class="s2">\n</span><span class="s3">&quot;</span>
    <span class="s1">msg += </span><span class="s3">&quot;  - pytest-tornasync</span><span class="s2">\n</span><span class="s3">&quot;</span>
    <span class="s1">msg += </span><span class="s3">&quot;  - pytest-trio</span><span class="s2">\n</span><span class="s3">&quot;</span>
    <span class="s1">msg += </span><span class="s3">&quot;  - pytest-twisted&quot;</span>
    <span class="s1">warnings.warn(PytestUnhandledCoroutineWarning(msg.format(nodeid)))</span>
    <span class="s1">skip(reason=</span><span class="s3">&quot;async def function and no async plugin installed (see warnings)&quot;</span><span class="s1">)</span>


<span class="s1">@hookimpl(trylast=</span><span class="s2">True</span><span class="s1">)</span>
<span class="s2">def </span><span class="s1">pytest_pyfunc_call(pyfuncitem: </span><span class="s3">&quot;Function&quot;</span><span class="s1">) -&gt; Optional[object]:</span>
    <span class="s1">testfunction = pyfuncitem.obj</span>
    <span class="s2">if </span><span class="s1">is_async_function(testfunction):</span>
        <span class="s1">async_warn_and_skip(pyfuncitem.nodeid)</span>
    <span class="s1">funcargs = pyfuncitem.funcargs</span>
    <span class="s1">testargs = {arg: funcargs[arg] </span><span class="s2">for </span><span class="s1">arg </span><span class="s2">in </span><span class="s1">pyfuncitem._fixtureinfo.argnames}</span>
    <span class="s1">result = testfunction(**testargs)</span>
    <span class="s2">if </span><span class="s1">hasattr(result</span><span class="s2">, </span><span class="s3">&quot;__await__&quot;</span><span class="s1">) </span><span class="s2">or </span><span class="s1">hasattr(result</span><span class="s2">, </span><span class="s3">&quot;__aiter__&quot;</span><span class="s1">):</span>
        <span class="s1">async_warn_and_skip(pyfuncitem.nodeid)</span>
    <span class="s2">return True</span>


<span class="s2">def </span><span class="s1">pytest_collect_file(file_path: Path</span><span class="s2">, </span><span class="s1">parent: nodes.Collector) -&gt; Optional[</span><span class="s3">&quot;Module&quot;</span><span class="s1">]:</span>
    <span class="s2">if </span><span class="s1">file_path.suffix == </span><span class="s3">&quot;.py&quot;</span><span class="s1">:</span>
        <span class="s2">if not </span><span class="s1">parent.session.isinitpath(file_path):</span>
            <span class="s2">if not </span><span class="s1">path_matches_patterns(</span>
                <span class="s1">file_path</span><span class="s2">, </span><span class="s1">parent.config.getini(</span><span class="s3">&quot;python_files&quot;</span><span class="s1">) + [</span><span class="s3">&quot;__init__.py&quot;</span><span class="s1">]</span>
            <span class="s1">):</span>
                <span class="s2">return None</span>
        <span class="s1">ihook = parent.session.gethookproxy(file_path)</span>
        <span class="s1">module: Module = ihook.pytest_pycollect_makemodule(</span>
            <span class="s1">module_path=file_path</span><span class="s2">, </span><span class="s1">parent=parent</span>
        <span class="s1">)</span>
        <span class="s2">return </span><span class="s1">module</span>
    <span class="s2">return None</span>


<span class="s2">def </span><span class="s1">path_matches_patterns(path: Path</span><span class="s2">, </span><span class="s1">patterns: Iterable[str]) -&gt; bool:</span>
    <span class="s0">&quot;&quot;&quot;Return whether path matches any of the patterns in the list of globs given.&quot;&quot;&quot;</span>
    <span class="s2">return </span><span class="s1">any(fnmatch_ex(pattern</span><span class="s2">, </span><span class="s1">path) </span><span class="s2">for </span><span class="s1">pattern </span><span class="s2">in </span><span class="s1">patterns)</span>


<span class="s2">def </span><span class="s1">pytest_pycollect_makemodule(module_path: Path</span><span class="s2">, </span><span class="s1">parent) -&gt; </span><span class="s3">&quot;Module&quot;</span><span class="s1">:</span>
    <span class="s2">if </span><span class="s1">module_path.name == </span><span class="s3">&quot;__init__.py&quot;</span><span class="s1">:</span>
        <span class="s1">pkg: Package = Package.from_parent(parent</span><span class="s2">, </span><span class="s1">path=module_path)</span>
        <span class="s2">return </span><span class="s1">pkg</span>
    <span class="s1">mod: Module = Module.from_parent(parent</span><span class="s2">, </span><span class="s1">path=module_path)</span>
    <span class="s2">return </span><span class="s1">mod</span>


<span class="s1">@hookimpl(trylast=</span><span class="s2">True</span><span class="s1">)</span>
<span class="s2">def </span><span class="s1">pytest_pycollect_makeitem(</span>
    <span class="s1">collector: Union[</span><span class="s3">&quot;Module&quot;</span><span class="s2">, </span><span class="s3">&quot;Class&quot;</span><span class="s1">]</span><span class="s2">, </span><span class="s1">name: str</span><span class="s2">, </span><span class="s1">obj: object</span>
<span class="s1">) -&gt; Union[</span><span class="s2">None, </span><span class="s1">nodes.Item</span><span class="s2">, </span><span class="s1">nodes.Collector</span><span class="s2">, </span><span class="s1">List[Union[nodes.Item</span><span class="s2">, </span><span class="s1">nodes.Collector]]]:</span>
    <span class="s2">assert </span><span class="s1">isinstance(collector</span><span class="s2">, </span><span class="s1">(Class</span><span class="s2">, </span><span class="s1">Module))</span><span class="s2">, </span><span class="s1">type(collector)</span>
    <span class="s4"># Nothing was collected elsewhere, let's do it here.</span>
    <span class="s2">if </span><span class="s1">safe_isclass(obj):</span>
        <span class="s2">if </span><span class="s1">collector.istestclass(obj</span><span class="s2">, </span><span class="s1">name):</span>
            <span class="s1">klass: Class = Class.from_parent(collector</span><span class="s2">, </span><span class="s1">name=name</span><span class="s2">, </span><span class="s1">obj=obj)</span>
            <span class="s2">return </span><span class="s1">klass</span>
    <span class="s2">elif </span><span class="s1">collector.istestfunction(obj</span><span class="s2">, </span><span class="s1">name):</span>
        <span class="s4"># mock seems to store unbound methods (issue473), normalize it.</span>
        <span class="s1">obj = getattr(obj</span><span class="s2">, </span><span class="s3">&quot;__func__&quot;</span><span class="s2">, </span><span class="s1">obj)</span>
        <span class="s4"># We need to try and unwrap the function if it's a functools.partial</span>
        <span class="s4"># or a functools.wrapped.</span>
        <span class="s4"># We mustn't if it's been wrapped with mock.patch (python 2 only).</span>
        <span class="s2">if not </span><span class="s1">(inspect.isfunction(obj) </span><span class="s2">or </span><span class="s1">inspect.isfunction(get_real_func(obj))):</span>
            <span class="s1">filename</span><span class="s2">, </span><span class="s1">lineno = getfslineno(obj)</span>
            <span class="s1">warnings.warn_explicit(</span>
                <span class="s1">message=PytestCollectionWarning(</span>
                    <span class="s3">&quot;cannot collect %r because it is not a function.&quot; </span><span class="s1">% name</span>
                <span class="s1">)</span><span class="s2">,</span>
                <span class="s1">category=</span><span class="s2">None,</span>
                <span class="s1">filename=str(filename)</span><span class="s2">,</span>
                <span class="s1">lineno=lineno + </span><span class="s5">1</span><span class="s2">,</span>
            <span class="s1">)</span>
        <span class="s2">elif </span><span class="s1">getattr(obj</span><span class="s2">, </span><span class="s3">&quot;__test__&quot;</span><span class="s2">, True</span><span class="s1">):</span>
            <span class="s2">if </span><span class="s1">is_generator(obj):</span>
                <span class="s1">res: Function = Function.from_parent(collector</span><span class="s2">, </span><span class="s1">name=name)</span>
                <span class="s1">reason = </span><span class="s3">&quot;yield tests were removed in pytest 4.0 - {name} will be ignored&quot;</span><span class="s1">.format(</span>
                    <span class="s1">name=name</span>
                <span class="s1">)</span>
                <span class="s1">res.add_marker(MARK_GEN.xfail(run=</span><span class="s2">False, </span><span class="s1">reason=reason))</span>
                <span class="s1">res.warn(PytestCollectionWarning(reason))</span>
                <span class="s2">return </span><span class="s1">res</span>
            <span class="s2">else</span><span class="s1">:</span>
                <span class="s2">return </span><span class="s1">list(collector._genfunctions(name</span><span class="s2">, </span><span class="s1">obj))</span>
    <span class="s2">return None</span>


<span class="s2">class </span><span class="s1">PyobjMixin(nodes.Node):</span>
    <span class="s0">&quot;&quot;&quot;this mix-in inherits from Node to carry over the typing information 
 
    as its intended to always mix in before a node 
    its position in the mro is unaffected&quot;&quot;&quot;</span>

    <span class="s1">_ALLOW_MARKERS = </span><span class="s2">True</span>

    <span class="s1">@property</span>
    <span class="s2">def </span><span class="s1">module(self):</span>
        <span class="s0">&quot;&quot;&quot;Python module object this node was collected from (can be None).&quot;&quot;&quot;</span>
        <span class="s1">node = self.getparent(Module)</span>
        <span class="s2">return </span><span class="s1">node.obj </span><span class="s2">if </span><span class="s1">node </span><span class="s2">is not None else None</span>

    <span class="s1">@property</span>
    <span class="s2">def </span><span class="s1">cls(self):</span>
        <span class="s0">&quot;&quot;&quot;Python class object this node was collected from (can be None).&quot;&quot;&quot;</span>
        <span class="s1">node = self.getparent(Class)</span>
        <span class="s2">return </span><span class="s1">node.obj </span><span class="s2">if </span><span class="s1">node </span><span class="s2">is not None else None</span>

    <span class="s1">@property</span>
    <span class="s2">def </span><span class="s1">instance(self):</span>
        <span class="s0">&quot;&quot;&quot;Python instance object the function is bound to. 
 
        Returns None if not a test method, e.g. for a standalone test function, 
        a staticmethod, a class or a module. 
        &quot;&quot;&quot;</span>
        <span class="s1">node = self.getparent(Function)</span>
        <span class="s2">return </span><span class="s1">getattr(node.obj</span><span class="s2">, </span><span class="s3">&quot;__self__&quot;</span><span class="s2">, None</span><span class="s1">) </span><span class="s2">if </span><span class="s1">node </span><span class="s2">is not None else None</span>

    <span class="s1">@property</span>
    <span class="s2">def </span><span class="s1">obj(self):</span>
        <span class="s0">&quot;&quot;&quot;Underlying Python object.&quot;&quot;&quot;</span>
        <span class="s1">obj = getattr(self</span><span class="s2">, </span><span class="s3">&quot;_obj&quot;</span><span class="s2">, None</span><span class="s1">)</span>
        <span class="s2">if </span><span class="s1">obj </span><span class="s2">is None</span><span class="s1">:</span>
            <span class="s1">self._obj = obj = self._getobj()</span>
            <span class="s4"># XXX evil hack</span>
            <span class="s4"># used to avoid Function marker duplication</span>
            <span class="s2">if </span><span class="s1">self._ALLOW_MARKERS:</span>
                <span class="s1">self.own_markers.extend(get_unpacked_marks(self.obj))</span>
                <span class="s4"># This assumes that `obj` is called before there is a chance</span>
                <span class="s4"># to add custom keys to `self.keywords`, so no fear of overriding.</span>
                <span class="s1">self.keywords.update((mark.name</span><span class="s2">, </span><span class="s1">mark) </span><span class="s2">for </span><span class="s1">mark </span><span class="s2">in </span><span class="s1">self.own_markers)</span>
        <span class="s2">return </span><span class="s1">obj</span>

    <span class="s1">@obj.setter</span>
    <span class="s2">def </span><span class="s1">obj(self</span><span class="s2">, </span><span class="s1">value):</span>
        <span class="s1">self._obj = value</span>

    <span class="s2">def </span><span class="s1">_getobj(self):</span>
        <span class="s0">&quot;&quot;&quot;Get the underlying Python object. May be overwritten by subclasses.&quot;&quot;&quot;</span>
        <span class="s4"># TODO: Improve the type of `parent` such that assert/ignore aren't needed.</span>
        <span class="s2">assert </span><span class="s1">self.parent </span><span class="s2">is not None</span>
        <span class="s1">obj = self.parent.obj  </span><span class="s4"># type: ignore[attr-defined]</span>
        <span class="s2">return </span><span class="s1">getattr(obj</span><span class="s2">, </span><span class="s1">self.name)</span>

    <span class="s2">def </span><span class="s1">getmodpath(self</span><span class="s2">, </span><span class="s1">stopatmodule: bool = </span><span class="s2">True, </span><span class="s1">includemodule: bool = </span><span class="s2">False</span><span class="s1">) -&gt; str:</span>
        <span class="s0">&quot;&quot;&quot;Return Python path relative to the containing module.&quot;&quot;&quot;</span>
        <span class="s1">chain = self.listchain()</span>
        <span class="s1">chain.reverse()</span>
        <span class="s1">parts = []</span>
        <span class="s2">for </span><span class="s1">node </span><span class="s2">in </span><span class="s1">chain:</span>
            <span class="s1">name = node.name</span>
            <span class="s2">if </span><span class="s1">isinstance(node</span><span class="s2">, </span><span class="s1">Module):</span>
                <span class="s1">name = os.path.splitext(name)[</span><span class="s5">0</span><span class="s1">]</span>
                <span class="s2">if </span><span class="s1">stopatmodule:</span>
                    <span class="s2">if </span><span class="s1">includemodule:</span>
                        <span class="s1">parts.append(name)</span>
                    <span class="s2">break</span>
            <span class="s1">parts.append(name)</span>
        <span class="s1">parts.reverse()</span>
        <span class="s2">return </span><span class="s3">&quot;.&quot;</span><span class="s1">.join(parts)</span>

    <span class="s2">def </span><span class="s1">reportinfo(self) -&gt; Tuple[Union[</span><span class="s3">&quot;os.PathLike[str]&quot;</span><span class="s2">, </span><span class="s1">str]</span><span class="s2">, </span><span class="s1">Optional[int]</span><span class="s2">, </span><span class="s1">str]:</span>
        <span class="s4"># XXX caching?</span>
        <span class="s1">obj = self.obj</span>
        <span class="s1">compat_co_firstlineno = getattr(obj</span><span class="s2">, </span><span class="s3">&quot;compat_co_firstlineno&quot;</span><span class="s2">, None</span><span class="s1">)</span>
        <span class="s2">if </span><span class="s1">isinstance(compat_co_firstlineno</span><span class="s2">, </span><span class="s1">int):</span>
            <span class="s4"># nose compatibility</span>
            <span class="s1">file_path = sys.modules[obj.__module__].__file__</span>
            <span class="s2">assert </span><span class="s1">file_path </span><span class="s2">is not None</span>
            <span class="s2">if </span><span class="s1">file_path.endswith(</span><span class="s3">&quot;.pyc&quot;</span><span class="s1">):</span>
                <span class="s1">file_path = file_path[:-</span><span class="s5">1</span><span class="s1">]</span>
            <span class="s1">path: Union[</span><span class="s3">&quot;os.PathLike[str]&quot;</span><span class="s2">, </span><span class="s1">str] = file_path</span>
            <span class="s1">lineno = compat_co_firstlineno</span>
        <span class="s2">else</span><span class="s1">:</span>
            <span class="s1">path</span><span class="s2">, </span><span class="s1">lineno = getfslineno(obj)</span>
        <span class="s1">modpath = self.getmodpath()</span>
        <span class="s2">assert </span><span class="s1">isinstance(lineno</span><span class="s2">, </span><span class="s1">int)</span>
        <span class="s2">return </span><span class="s1">path</span><span class="s2">, </span><span class="s1">lineno</span><span class="s2">, </span><span class="s1">modpath</span>


<span class="s4"># As an optimization, these builtin attribute names are pre-ignored when</span>
<span class="s4"># iterating over an object during collection -- the pytest_pycollect_makeitem</span>
<span class="s4"># hook is not called for them.</span>
<span class="s4"># fmt: off</span>
<span class="s2">class </span><span class="s1">_EmptyClass: </span><span class="s2">pass  </span><span class="s4"># noqa: E701</span>
<span class="s1">IGNORED_ATTRIBUTES = frozenset.union(  </span><span class="s4"># noqa: E305</span>
    <span class="s1">frozenset()</span><span class="s2">,</span>
    <span class="s4"># Module.</span>
    <span class="s1">dir(types.ModuleType(</span><span class="s3">&quot;empty_module&quot;</span><span class="s1">))</span><span class="s2">,</span>
    <span class="s4"># Some extra module attributes the above doesn't catch.</span>
    <span class="s1">{</span><span class="s3">&quot;__builtins__&quot;</span><span class="s2">, </span><span class="s3">&quot;__file__&quot;</span><span class="s2">, </span><span class="s3">&quot;__cached__&quot;</span><span class="s1">}</span><span class="s2">,</span>
    <span class="s4"># Class.</span>
    <span class="s1">dir(_EmptyClass)</span><span class="s2">,</span>
    <span class="s4"># Instance.</span>
    <span class="s1">dir(_EmptyClass())</span><span class="s2">,</span>
<span class="s1">)</span>
<span class="s2">del </span><span class="s1">_EmptyClass</span>
<span class="s4"># fmt: on</span>


<span class="s2">class </span><span class="s1">PyCollector(PyobjMixin</span><span class="s2">, </span><span class="s1">nodes.Collector):</span>
    <span class="s2">def </span><span class="s1">funcnamefilter(self</span><span class="s2">, </span><span class="s1">name: str) -&gt; bool:</span>
        <span class="s2">return </span><span class="s1">self._matches_prefix_or_glob_option(</span><span class="s3">&quot;python_functions&quot;</span><span class="s2">, </span><span class="s1">name)</span>

    <span class="s2">def </span><span class="s1">isnosetest(self</span><span class="s2">, </span><span class="s1">obj: object) -&gt; bool:</span>
        <span class="s0">&quot;&quot;&quot;Look for the __test__ attribute, which is applied by the 
        @nose.tools.istest decorator. 
        &quot;&quot;&quot;</span>
        <span class="s4"># We explicitly check for &quot;is True&quot; here to not mistakenly treat</span>
        <span class="s4"># classes with a custom __getattr__ returning something truthy (like a</span>
        <span class="s4"># function) as test classes.</span>
        <span class="s2">return </span><span class="s1">safe_getattr(obj</span><span class="s2">, </span><span class="s3">&quot;__test__&quot;</span><span class="s2">, False</span><span class="s1">) </span><span class="s2">is True</span>

    <span class="s2">def </span><span class="s1">classnamefilter(self</span><span class="s2">, </span><span class="s1">name: str) -&gt; bool:</span>
        <span class="s2">return </span><span class="s1">self._matches_prefix_or_glob_option(</span><span class="s3">&quot;python_classes&quot;</span><span class="s2">, </span><span class="s1">name)</span>

    <span class="s2">def </span><span class="s1">istestfunction(self</span><span class="s2">, </span><span class="s1">obj: object</span><span class="s2">, </span><span class="s1">name: str) -&gt; bool:</span>
        <span class="s2">if </span><span class="s1">self.funcnamefilter(name) </span><span class="s2">or </span><span class="s1">self.isnosetest(obj):</span>
            <span class="s2">if </span><span class="s1">isinstance(obj</span><span class="s2">, </span><span class="s1">staticmethod):</span>
                <span class="s4"># staticmethods need to be unwrapped.</span>
                <span class="s1">obj = safe_getattr(obj</span><span class="s2">, </span><span class="s3">&quot;__func__&quot;</span><span class="s2">, False</span><span class="s1">)</span>
            <span class="s2">return </span><span class="s1">callable(obj) </span><span class="s2">and </span><span class="s1">fixtures.getfixturemarker(obj) </span><span class="s2">is None</span>
        <span class="s2">else</span><span class="s1">:</span>
            <span class="s2">return False</span>

    <span class="s2">def </span><span class="s1">istestclass(self</span><span class="s2">, </span><span class="s1">obj: object</span><span class="s2">, </span><span class="s1">name: str) -&gt; bool:</span>
        <span class="s2">return </span><span class="s1">self.classnamefilter(name) </span><span class="s2">or </span><span class="s1">self.isnosetest(obj)</span>

    <span class="s2">def </span><span class="s1">_matches_prefix_or_glob_option(self</span><span class="s2">, </span><span class="s1">option_name: str</span><span class="s2">, </span><span class="s1">name: str) -&gt; bool:</span>
        <span class="s0">&quot;&quot;&quot;Check if the given name matches the prefix or glob-pattern defined 
        in ini configuration.&quot;&quot;&quot;</span>
        <span class="s2">for </span><span class="s1">option </span><span class="s2">in </span><span class="s1">self.config.getini(option_name):</span>
            <span class="s2">if </span><span class="s1">name.startswith(option):</span>
                <span class="s2">return True</span>
            <span class="s4"># Check that name looks like a glob-string before calling fnmatch</span>
            <span class="s4"># because this is called for every name in each collected module,</span>
            <span class="s4"># and fnmatch is somewhat expensive to call.</span>
            <span class="s2">elif </span><span class="s1">(</span><span class="s3">&quot;*&quot; </span><span class="s2">in </span><span class="s1">option </span><span class="s2">or </span><span class="s3">&quot;?&quot; </span><span class="s2">in </span><span class="s1">option </span><span class="s2">or </span><span class="s3">&quot;[&quot; </span><span class="s2">in </span><span class="s1">option) </span><span class="s2">and </span><span class="s1">fnmatch.fnmatch(</span>
                <span class="s1">name</span><span class="s2">, </span><span class="s1">option</span>
            <span class="s1">):</span>
                <span class="s2">return True</span>
        <span class="s2">return False</span>

    <span class="s2">def </span><span class="s1">collect(self) -&gt; Iterable[Union[nodes.Item</span><span class="s2">, </span><span class="s1">nodes.Collector]]:</span>
        <span class="s2">if not </span><span class="s1">getattr(self.obj</span><span class="s2">, </span><span class="s3">&quot;__test__&quot;</span><span class="s2">, True</span><span class="s1">):</span>
            <span class="s2">return </span><span class="s1">[]</span>

        <span class="s4"># Avoid random getattrs and peek in the __dict__ instead.</span>
        <span class="s1">dicts = [getattr(self.obj</span><span class="s2">, </span><span class="s3">&quot;__dict__&quot;</span><span class="s2">, </span><span class="s1">{})]</span>
        <span class="s2">if </span><span class="s1">isinstance(self.obj</span><span class="s2">, </span><span class="s1">type):</span>
            <span class="s2">for </span><span class="s1">basecls </span><span class="s2">in </span><span class="s1">self.obj.__mro__:</span>
                <span class="s1">dicts.append(basecls.__dict__)</span>

        <span class="s4"># In each class, nodes should be definition ordered.</span>
        <span class="s4"># __dict__ is definition ordered.</span>
        <span class="s1">seen: Set[str] = set()</span>
        <span class="s1">dict_values: List[List[Union[nodes.Item</span><span class="s2">, </span><span class="s1">nodes.Collector]]] = []</span>
        <span class="s1">ihook = self.ihook</span>
        <span class="s2">for </span><span class="s1">dic </span><span class="s2">in </span><span class="s1">dicts:</span>
            <span class="s1">values: List[Union[nodes.Item</span><span class="s2">, </span><span class="s1">nodes.Collector]] = []</span>
            <span class="s4"># Note: seems like the dict can change during iteration -</span>
            <span class="s4"># be careful not to remove the list() without consideration.</span>
            <span class="s2">for </span><span class="s1">name</span><span class="s2">, </span><span class="s1">obj </span><span class="s2">in </span><span class="s1">list(dic.items()):</span>
                <span class="s2">if </span><span class="s1">name </span><span class="s2">in </span><span class="s1">IGNORED_ATTRIBUTES:</span>
                    <span class="s2">continue</span>
                <span class="s2">if </span><span class="s1">name </span><span class="s2">in </span><span class="s1">seen:</span>
                    <span class="s2">continue</span>
                <span class="s1">seen.add(name)</span>
                <span class="s1">res = ihook.pytest_pycollect_makeitem(</span>
                    <span class="s1">collector=self</span><span class="s2">, </span><span class="s1">name=name</span><span class="s2">, </span><span class="s1">obj=obj</span>
                <span class="s1">)</span>
                <span class="s2">if </span><span class="s1">res </span><span class="s2">is None</span><span class="s1">:</span>
                    <span class="s2">continue</span>
                <span class="s2">elif </span><span class="s1">isinstance(res</span><span class="s2">, </span><span class="s1">list):</span>
                    <span class="s1">values.extend(res)</span>
                <span class="s2">else</span><span class="s1">:</span>
                    <span class="s1">values.append(res)</span>
            <span class="s1">dict_values.append(values)</span>

        <span class="s4"># Between classes in the class hierarchy, reverse-MRO order -- nodes</span>
        <span class="s4"># inherited from base classes should come before subclasses.</span>
        <span class="s1">result = []</span>
        <span class="s2">for </span><span class="s1">values </span><span class="s2">in </span><span class="s1">reversed(dict_values):</span>
            <span class="s1">result.extend(values)</span>
        <span class="s2">return </span><span class="s1">result</span>

    <span class="s2">def </span><span class="s1">_genfunctions(self</span><span class="s2">, </span><span class="s1">name: str</span><span class="s2">, </span><span class="s1">funcobj) -&gt; Iterator[</span><span class="s3">&quot;Function&quot;</span><span class="s1">]:</span>
        <span class="s1">modulecol = self.getparent(Module)</span>
        <span class="s2">assert </span><span class="s1">modulecol </span><span class="s2">is not None</span>
        <span class="s1">module = modulecol.obj</span>
        <span class="s1">clscol = self.getparent(Class)</span>
        <span class="s1">cls = clscol </span><span class="s2">and </span><span class="s1">clscol.obj </span><span class="s2">or None</span>

        <span class="s1">definition = FunctionDefinition.from_parent(self</span><span class="s2">, </span><span class="s1">name=name</span><span class="s2">, </span><span class="s1">callobj=funcobj)</span>
        <span class="s1">fixtureinfo = definition._fixtureinfo</span>

        <span class="s4"># pytest_generate_tests impls call metafunc.parametrize() which fills</span>
        <span class="s4"># metafunc._calls, the outcome of the hook.</span>
        <span class="s1">metafunc = Metafunc(</span>
            <span class="s1">definition=definition</span><span class="s2">,</span>
            <span class="s1">fixtureinfo=fixtureinfo</span><span class="s2">,</span>
            <span class="s1">config=self.config</span><span class="s2">,</span>
            <span class="s1">cls=cls</span><span class="s2">,</span>
            <span class="s1">module=module</span><span class="s2">,</span>
            <span class="s1">_ispytest=</span><span class="s2">True,</span>
        <span class="s1">)</span>
        <span class="s1">methods = []</span>
        <span class="s2">if </span><span class="s1">hasattr(module</span><span class="s2">, </span><span class="s3">&quot;pytest_generate_tests&quot;</span><span class="s1">):</span>
            <span class="s1">methods.append(module.pytest_generate_tests)</span>
        <span class="s2">if </span><span class="s1">cls </span><span class="s2">is not None and </span><span class="s1">hasattr(cls</span><span class="s2">, </span><span class="s3">&quot;pytest_generate_tests&quot;</span><span class="s1">):</span>
            <span class="s1">methods.append(cls().pytest_generate_tests)</span>
        <span class="s1">self.ihook.pytest_generate_tests.call_extra(methods</span><span class="s2">, </span><span class="s1">dict(metafunc=metafunc))</span>

        <span class="s2">if not </span><span class="s1">metafunc._calls:</span>
            <span class="s2">yield </span><span class="s1">Function.from_parent(self</span><span class="s2">, </span><span class="s1">name=name</span><span class="s2">, </span><span class="s1">fixtureinfo=fixtureinfo)</span>
        <span class="s2">else</span><span class="s1">:</span>
            <span class="s4"># Add funcargs() as fixturedefs to fixtureinfo.arg2fixturedefs.</span>
            <span class="s1">fm = self.session._fixturemanager</span>
            <span class="s1">fixtures.add_funcarg_pseudo_fixture_def(self</span><span class="s2">, </span><span class="s1">metafunc</span><span class="s2">, </span><span class="s1">fm)</span>

            <span class="s4"># Add_funcarg_pseudo_fixture_def may have shadowed some fixtures</span>
            <span class="s4"># with direct parametrization, so make sure we update what the</span>
            <span class="s4"># function really needs.</span>
            <span class="s1">fixtureinfo.prune_dependency_tree()</span>

            <span class="s2">for </span><span class="s1">callspec </span><span class="s2">in </span><span class="s1">metafunc._calls:</span>
                <span class="s1">subname = </span><span class="s3">f&quot;</span><span class="s2">{</span><span class="s1">name</span><span class="s2">}</span><span class="s3">[</span><span class="s2">{</span><span class="s1">callspec.id</span><span class="s2">}</span><span class="s3">]&quot;</span>
                <span class="s2">yield </span><span class="s1">Function.from_parent(</span>
                    <span class="s1">self</span><span class="s2">,</span>
                    <span class="s1">name=subname</span><span class="s2">,</span>
                    <span class="s1">callspec=callspec</span><span class="s2">,</span>
                    <span class="s1">fixtureinfo=fixtureinfo</span><span class="s2">,</span>
                    <span class="s1">keywords={callspec.id: </span><span class="s2">True</span><span class="s1">}</span><span class="s2">,</span>
                    <span class="s1">originalname=name</span><span class="s2">,</span>
                <span class="s1">)</span>


<span class="s2">class </span><span class="s1">Module(nodes.File</span><span class="s2">, </span><span class="s1">PyCollector):</span>
    <span class="s0">&quot;&quot;&quot;Collector for test classes and functions.&quot;&quot;&quot;</span>

    <span class="s2">def </span><span class="s1">_getobj(self):</span>
        <span class="s2">return </span><span class="s1">self._importtestmodule()</span>

    <span class="s2">def </span><span class="s1">collect(self) -&gt; Iterable[Union[nodes.Item</span><span class="s2">, </span><span class="s1">nodes.Collector]]:</span>
        <span class="s1">self._inject_setup_module_fixture()</span>
        <span class="s1">self._inject_setup_function_fixture()</span>
        <span class="s1">self.session._fixturemanager.parsefactories(self)</span>
        <span class="s2">return </span><span class="s1">super().collect()</span>

    <span class="s2">def </span><span class="s1">_inject_setup_module_fixture(self) -&gt; </span><span class="s2">None</span><span class="s1">:</span>
        <span class="s0">&quot;&quot;&quot;Inject a hidden autouse, module scoped fixture into the collected module object 
        that invokes setUpModule/tearDownModule if either or both are available. 
 
        Using a fixture to invoke this methods ensures we play nicely and unsurprisingly with 
        other fixtures (#517). 
        &quot;&quot;&quot;</span>
        <span class="s1">has_nose = self.config.pluginmanager.has_plugin(</span><span class="s3">&quot;nose&quot;</span><span class="s1">)</span>
        <span class="s1">setup_module = _get_first_non_fixture_func(</span>
            <span class="s1">self.obj</span><span class="s2">, </span><span class="s1">(</span><span class="s3">&quot;setUpModule&quot;</span><span class="s2">, </span><span class="s3">&quot;setup_module&quot;</span><span class="s1">)</span>
        <span class="s1">)</span>
        <span class="s2">if </span><span class="s1">setup_module </span><span class="s2">is None and </span><span class="s1">has_nose:</span>
            <span class="s4"># The name &quot;setup&quot; is too common - only treat as fixture if callable.</span>
            <span class="s1">setup_module = _get_first_non_fixture_func(self.obj</span><span class="s2">, </span><span class="s1">(</span><span class="s3">&quot;setup&quot;</span><span class="s2">,</span><span class="s1">))</span>
            <span class="s2">if not </span><span class="s1">callable(setup_module):</span>
                <span class="s1">setup_module = </span><span class="s2">None</span>
        <span class="s1">teardown_module = _get_first_non_fixture_func(</span>
            <span class="s1">self.obj</span><span class="s2">, </span><span class="s1">(</span><span class="s3">&quot;tearDownModule&quot;</span><span class="s2">, </span><span class="s3">&quot;teardown_module&quot;</span><span class="s1">)</span>
        <span class="s1">)</span>
        <span class="s2">if </span><span class="s1">teardown_module </span><span class="s2">is None and </span><span class="s1">has_nose:</span>
            <span class="s1">teardown_module = _get_first_non_fixture_func(self.obj</span><span class="s2">, </span><span class="s1">(</span><span class="s3">&quot;teardown&quot;</span><span class="s2">,</span><span class="s1">))</span>
            <span class="s4"># Same as &quot;setup&quot; above - only treat as fixture if callable.</span>
            <span class="s2">if not </span><span class="s1">callable(teardown_module):</span>
                <span class="s1">teardown_module = </span><span class="s2">None</span>

        <span class="s2">if </span><span class="s1">setup_module </span><span class="s2">is None and </span><span class="s1">teardown_module </span><span class="s2">is None</span><span class="s1">:</span>
            <span class="s2">return</span>

        <span class="s1">@fixtures.fixture(</span>
            <span class="s1">autouse=</span><span class="s2">True,</span>
            <span class="s1">scope=</span><span class="s3">&quot;module&quot;</span><span class="s2">,</span>
            <span class="s4"># Use a unique name to speed up lookup.</span>
            <span class="s1">name=</span><span class="s3">f&quot;_xunit_setup_module_fixture_</span><span class="s2">{</span><span class="s1">self.obj.__name__</span><span class="s2">}</span><span class="s3">&quot;</span><span class="s2">,</span>
        <span class="s1">)</span>
        <span class="s2">def </span><span class="s1">xunit_setup_module_fixture(request) -&gt; Generator[</span><span class="s2">None, None, None</span><span class="s1">]:</span>
            <span class="s2">if </span><span class="s1">setup_module </span><span class="s2">is not None</span><span class="s1">:</span>
                <span class="s1">_call_with_optional_argument(setup_module</span><span class="s2">, </span><span class="s1">request.module)</span>
            <span class="s2">yield</span>
            <span class="s2">if </span><span class="s1">teardown_module </span><span class="s2">is not None</span><span class="s1">:</span>
                <span class="s1">_call_with_optional_argument(teardown_module</span><span class="s2">, </span><span class="s1">request.module)</span>

        <span class="s1">self.obj.__pytest_setup_module = xunit_setup_module_fixture</span>

    <span class="s2">def </span><span class="s1">_inject_setup_function_fixture(self) -&gt; </span><span class="s2">None</span><span class="s1">:</span>
        <span class="s0">&quot;&quot;&quot;Inject a hidden autouse, function scoped fixture into the collected module object 
        that invokes setup_function/teardown_function if either or both are available. 
 
        Using a fixture to invoke this methods ensures we play nicely and unsurprisingly with 
        other fixtures (#517). 
        &quot;&quot;&quot;</span>
        <span class="s1">setup_function = _get_first_non_fixture_func(self.obj</span><span class="s2">, </span><span class="s1">(</span><span class="s3">&quot;setup_function&quot;</span><span class="s2">,</span><span class="s1">))</span>
        <span class="s1">teardown_function = _get_first_non_fixture_func(</span>
            <span class="s1">self.obj</span><span class="s2">, </span><span class="s1">(</span><span class="s3">&quot;teardown_function&quot;</span><span class="s2">,</span><span class="s1">)</span>
        <span class="s1">)</span>
        <span class="s2">if </span><span class="s1">setup_function </span><span class="s2">is None and </span><span class="s1">teardown_function </span><span class="s2">is None</span><span class="s1">:</span>
            <span class="s2">return</span>

        <span class="s1">@fixtures.fixture(</span>
            <span class="s1">autouse=</span><span class="s2">True,</span>
            <span class="s1">scope=</span><span class="s3">&quot;function&quot;</span><span class="s2">,</span>
            <span class="s4"># Use a unique name to speed up lookup.</span>
            <span class="s1">name=</span><span class="s3">f&quot;_xunit_setup_function_fixture_</span><span class="s2">{</span><span class="s1">self.obj.__name__</span><span class="s2">}</span><span class="s3">&quot;</span><span class="s2">,</span>
        <span class="s1">)</span>
        <span class="s2">def </span><span class="s1">xunit_setup_function_fixture(request) -&gt; Generator[</span><span class="s2">None, None, None</span><span class="s1">]:</span>
            <span class="s2">if </span><span class="s1">request.instance </span><span class="s2">is not None</span><span class="s1">:</span>
                <span class="s4"># in this case we are bound to an instance, so we need to let</span>
                <span class="s4"># setup_method handle this</span>
                <span class="s2">yield</span>
                <span class="s2">return</span>
            <span class="s2">if </span><span class="s1">setup_function </span><span class="s2">is not None</span><span class="s1">:</span>
                <span class="s1">_call_with_optional_argument(setup_function</span><span class="s2">, </span><span class="s1">request.function)</span>
            <span class="s2">yield</span>
            <span class="s2">if </span><span class="s1">teardown_function </span><span class="s2">is not None</span><span class="s1">:</span>
                <span class="s1">_call_with_optional_argument(teardown_function</span><span class="s2">, </span><span class="s1">request.function)</span>

        <span class="s1">self.obj.__pytest_setup_function = xunit_setup_function_fixture</span>

    <span class="s2">def </span><span class="s1">_importtestmodule(self):</span>
        <span class="s4"># We assume we are only called once per module.</span>
        <span class="s1">importmode = self.config.getoption(</span><span class="s3">&quot;--import-mode&quot;</span><span class="s1">)</span>
        <span class="s2">try</span><span class="s1">:</span>
            <span class="s1">mod = import_path(self.path</span><span class="s2">, </span><span class="s1">mode=importmode</span><span class="s2">, </span><span class="s1">root=self.config.rootpath)</span>
        <span class="s2">except </span><span class="s1">SyntaxError </span><span class="s2">as </span><span class="s1">e:</span>
            <span class="s2">raise </span><span class="s1">self.CollectError(</span>
                <span class="s1">ExceptionInfo.from_current().getrepr(style=</span><span class="s3">&quot;short&quot;</span><span class="s1">)</span>
            <span class="s1">) </span><span class="s2">from </span><span class="s1">e</span>
        <span class="s2">except </span><span class="s1">ImportPathMismatchError </span><span class="s2">as </span><span class="s1">e:</span>
            <span class="s2">raise </span><span class="s1">self.CollectError(</span>
                <span class="s3">&quot;import file mismatch:</span><span class="s2">\n</span><span class="s3">&quot;</span>
                <span class="s3">&quot;imported module %r has this __file__ attribute:</span><span class="s2">\n</span><span class="s3">&quot;</span>
                <span class="s3">&quot;  %s</span><span class="s2">\n</span><span class="s3">&quot;</span>
                <span class="s3">&quot;which is not the same as the test file we want to collect:</span><span class="s2">\n</span><span class="s3">&quot;</span>
                <span class="s3">&quot;  %s</span><span class="s2">\n</span><span class="s3">&quot;</span>
                <span class="s3">&quot;HINT: remove __pycache__ / .pyc files and/or use a &quot;</span>
                <span class="s3">&quot;unique basename for your test file modules&quot; </span><span class="s1">% e.args</span>
            <span class="s1">) </span><span class="s2">from </span><span class="s1">e</span>
        <span class="s2">except </span><span class="s1">ImportError </span><span class="s2">as </span><span class="s1">e:</span>
            <span class="s1">exc_info = ExceptionInfo.from_current()</span>
            <span class="s2">if </span><span class="s1">self.config.getoption(</span><span class="s3">&quot;verbose&quot;</span><span class="s1">) &lt; </span><span class="s5">2</span><span class="s1">:</span>
                <span class="s1">exc_info.traceback = exc_info.traceback.filter(filter_traceback)</span>
            <span class="s1">exc_repr = (</span>
                <span class="s1">exc_info.getrepr(style=</span><span class="s3">&quot;short&quot;</span><span class="s1">)</span>
                <span class="s2">if </span><span class="s1">exc_info.traceback</span>
                <span class="s2">else </span><span class="s1">exc_info.exconly()</span>
            <span class="s1">)</span>
            <span class="s1">formatted_tb = str(exc_repr)</span>
            <span class="s2">raise </span><span class="s1">self.CollectError(</span>
                <span class="s3">&quot;ImportError while importing test module '{path}'.</span><span class="s2">\n</span><span class="s3">&quot;</span>
                <span class="s3">&quot;Hint: make sure your test modules/packages have valid Python names.</span><span class="s2">\n</span><span class="s3">&quot;</span>
                <span class="s3">&quot;Traceback:</span><span class="s2">\n</span><span class="s3">&quot;</span>
                <span class="s3">&quot;{traceback}&quot;</span><span class="s1">.format(path=self.path</span><span class="s2">, </span><span class="s1">traceback=formatted_tb)</span>
            <span class="s1">) </span><span class="s2">from </span><span class="s1">e</span>
        <span class="s2">except </span><span class="s1">skip.Exception </span><span class="s2">as </span><span class="s1">e:</span>
            <span class="s2">if </span><span class="s1">e.allow_module_level:</span>
                <span class="s2">raise</span>
            <span class="s2">raise </span><span class="s1">self.CollectError(</span>
                <span class="s3">&quot;Using pytest.skip outside of a test will skip the entire module. &quot;</span>
                <span class="s3">&quot;If that's your intention, pass `allow_module_level=True`. &quot;</span>
                <span class="s3">&quot;If you want to skip a specific test or an entire class, &quot;</span>
                <span class="s3">&quot;use the @pytest.mark.skip or @pytest.mark.skipif decorators.&quot;</span>
            <span class="s1">) </span><span class="s2">from </span><span class="s1">e</span>
        <span class="s1">self.config.pluginmanager.consider_module(mod)</span>
        <span class="s2">return </span><span class="s1">mod</span>


<span class="s2">class </span><span class="s1">Package(Module):</span>
    <span class="s2">def </span><span class="s1">__init__(</span>
        <span class="s1">self</span><span class="s2">,</span>
        <span class="s1">fspath: Optional[LEGACY_PATH]</span><span class="s2">,</span>
        <span class="s1">parent: nodes.Collector</span><span class="s2">,</span>
        <span class="s4"># NOTE: following args are unused:</span>
        <span class="s1">config=</span><span class="s2">None,</span>
        <span class="s1">session=</span><span class="s2">None,</span>
        <span class="s1">nodeid=</span><span class="s2">None,</span>
        <span class="s1">path=Optional[Path]</span><span class="s2">,</span>
    <span class="s1">) -&gt; </span><span class="s2">None</span><span class="s1">:</span>
        <span class="s4"># NOTE: Could be just the following, but kept as-is for compat.</span>
        <span class="s4"># nodes.FSCollector.__init__(self, fspath, parent=parent)</span>
        <span class="s1">session = parent.session</span>
        <span class="s1">nodes.FSCollector.__init__(</span>
            <span class="s1">self</span><span class="s2">,</span>
            <span class="s1">fspath=fspath</span><span class="s2">,</span>
            <span class="s1">path=path</span><span class="s2">,</span>
            <span class="s1">parent=parent</span><span class="s2">,</span>
            <span class="s1">config=config</span><span class="s2">,</span>
            <span class="s1">session=session</span><span class="s2">,</span>
            <span class="s1">nodeid=nodeid</span><span class="s2">,</span>
        <span class="s1">)</span>
        <span class="s1">self.name = self.path.parent.name</span>

    <span class="s2">def </span><span class="s1">setup(self) -&gt; </span><span class="s2">None</span><span class="s1">:</span>
        <span class="s4"># Not using fixtures to call setup_module here because autouse fixtures</span>
        <span class="s4"># from packages are not called automatically (#4085).</span>
        <span class="s1">setup_module = _get_first_non_fixture_func(</span>
            <span class="s1">self.obj</span><span class="s2">, </span><span class="s1">(</span><span class="s3">&quot;setUpModule&quot;</span><span class="s2">, </span><span class="s3">&quot;setup_module&quot;</span><span class="s1">)</span>
        <span class="s1">)</span>
        <span class="s2">if </span><span class="s1">setup_module </span><span class="s2">is not None</span><span class="s1">:</span>
            <span class="s1">_call_with_optional_argument(setup_module</span><span class="s2">, </span><span class="s1">self.obj)</span>

        <span class="s1">teardown_module = _get_first_non_fixture_func(</span>
            <span class="s1">self.obj</span><span class="s2">, </span><span class="s1">(</span><span class="s3">&quot;tearDownModule&quot;</span><span class="s2">, </span><span class="s3">&quot;teardown_module&quot;</span><span class="s1">)</span>
        <span class="s1">)</span>
        <span class="s2">if </span><span class="s1">teardown_module </span><span class="s2">is not None</span><span class="s1">:</span>
            <span class="s1">func = partial(_call_with_optional_argument</span><span class="s2">, </span><span class="s1">teardown_module</span><span class="s2">, </span><span class="s1">self.obj)</span>
            <span class="s1">self.addfinalizer(func)</span>

    <span class="s2">def </span><span class="s1">gethookproxy(self</span><span class="s2">, </span><span class="s1">fspath: </span><span class="s3">&quot;os.PathLike[str]&quot;</span><span class="s1">):</span>
        <span class="s1">warnings.warn(FSCOLLECTOR_GETHOOKPROXY_ISINITPATH</span><span class="s2">, </span><span class="s1">stacklevel=</span><span class="s5">2</span><span class="s1">)</span>
        <span class="s2">return </span><span class="s1">self.session.gethookproxy(fspath)</span>

    <span class="s2">def </span><span class="s1">isinitpath(self</span><span class="s2">, </span><span class="s1">path: Union[str</span><span class="s2">, </span><span class="s3">&quot;os.PathLike[str]&quot;</span><span class="s1">]) -&gt; bool:</span>
        <span class="s1">warnings.warn(FSCOLLECTOR_GETHOOKPROXY_ISINITPATH</span><span class="s2">, </span><span class="s1">stacklevel=</span><span class="s5">2</span><span class="s1">)</span>
        <span class="s2">return </span><span class="s1">self.session.isinitpath(path)</span>

    <span class="s2">def </span><span class="s1">_recurse(self</span><span class="s2">, </span><span class="s1">direntry: </span><span class="s3">&quot;os.DirEntry[str]&quot;</span><span class="s1">) -&gt; bool:</span>
        <span class="s2">if </span><span class="s1">direntry.name == </span><span class="s3">&quot;__pycache__&quot;</span><span class="s1">:</span>
            <span class="s2">return False</span>
        <span class="s1">fspath = Path(direntry.path)</span>
        <span class="s1">ihook = self.session.gethookproxy(fspath.parent)</span>
        <span class="s2">if </span><span class="s1">ihook.pytest_ignore_collect(collection_path=fspath</span><span class="s2">, </span><span class="s1">config=self.config):</span>
            <span class="s2">return False</span>
        <span class="s1">norecursepatterns = self.config.getini(</span><span class="s3">&quot;norecursedirs&quot;</span><span class="s1">)</span>
        <span class="s2">if </span><span class="s1">any(fnmatch_ex(pat</span><span class="s2">, </span><span class="s1">fspath) </span><span class="s2">for </span><span class="s1">pat </span><span class="s2">in </span><span class="s1">norecursepatterns):</span>
            <span class="s2">return False</span>
        <span class="s2">return True</span>

    <span class="s2">def </span><span class="s1">_collectfile(</span>
        <span class="s1">self</span><span class="s2">, </span><span class="s1">fspath: Path</span><span class="s2">, </span><span class="s1">handle_dupes: bool = </span><span class="s2">True</span>
    <span class="s1">) -&gt; Sequence[nodes.Collector]:</span>
        <span class="s2">assert </span><span class="s1">(</span>
            <span class="s1">fspath.is_file()</span>
        <span class="s1">)</span><span class="s2">, </span><span class="s3">&quot;{!r} is not a file (isdir={!r}, exists={!r}, islink={!r})&quot;</span><span class="s1">.format(</span>
            <span class="s1">fspath</span><span class="s2">, </span><span class="s1">fspath.is_dir()</span><span class="s2">, </span><span class="s1">fspath.exists()</span><span class="s2">, </span><span class="s1">fspath.is_symlink()</span>
        <span class="s1">)</span>
        <span class="s1">ihook = self.session.gethookproxy(fspath)</span>
        <span class="s2">if not </span><span class="s1">self.session.isinitpath(fspath):</span>
            <span class="s2">if </span><span class="s1">ihook.pytest_ignore_collect(collection_path=fspath</span><span class="s2">, </span><span class="s1">config=self.config):</span>
                <span class="s2">return </span><span class="s1">()</span>

        <span class="s2">if </span><span class="s1">handle_dupes:</span>
            <span class="s1">keepduplicates = self.config.getoption(</span><span class="s3">&quot;keepduplicates&quot;</span><span class="s1">)</span>
            <span class="s2">if not </span><span class="s1">keepduplicates:</span>
                <span class="s1">duplicate_paths = self.config.pluginmanager._duplicatepaths</span>
                <span class="s2">if </span><span class="s1">fspath </span><span class="s2">in </span><span class="s1">duplicate_paths:</span>
                    <span class="s2">return </span><span class="s1">()</span>
                <span class="s2">else</span><span class="s1">:</span>
                    <span class="s1">duplicate_paths.add(fspath)</span>

        <span class="s2">return </span><span class="s1">ihook.pytest_collect_file(file_path=fspath</span><span class="s2">, </span><span class="s1">parent=self)  </span><span class="s4"># type: ignore[no-any-return]</span>

    <span class="s2">def </span><span class="s1">collect(self) -&gt; Iterable[Union[nodes.Item</span><span class="s2">, </span><span class="s1">nodes.Collector]]:</span>
        <span class="s1">this_path = self.path.parent</span>
        <span class="s1">init_module = this_path / </span><span class="s3">&quot;__init__.py&quot;</span>
        <span class="s2">if </span><span class="s1">init_module.is_file() </span><span class="s2">and </span><span class="s1">path_matches_patterns(</span>
            <span class="s1">init_module</span><span class="s2">, </span><span class="s1">self.config.getini(</span><span class="s3">&quot;python_files&quot;</span><span class="s1">)</span>
        <span class="s1">):</span>
            <span class="s2">yield </span><span class="s1">Module.from_parent(self</span><span class="s2">, </span><span class="s1">path=init_module)</span>
        <span class="s1">pkg_prefixes: Set[Path] = set()</span>
        <span class="s2">for </span><span class="s1">direntry </span><span class="s2">in </span><span class="s1">visit(str(this_path)</span><span class="s2">, </span><span class="s1">recurse=self._recurse):</span>
            <span class="s1">path = Path(direntry.path)</span>

            <span class="s4"># We will visit our own __init__.py file, in which case we skip it.</span>
            <span class="s2">if </span><span class="s1">direntry.is_file():</span>
                <span class="s2">if </span><span class="s1">direntry.name == </span><span class="s3">&quot;__init__.py&quot; </span><span class="s2">and </span><span class="s1">path.parent == this_path:</span>
                    <span class="s2">continue</span>

            <span class="s1">parts_ = parts(direntry.path)</span>
            <span class="s2">if </span><span class="s1">any(</span>
                <span class="s1">str(pkg_prefix) </span><span class="s2">in </span><span class="s1">parts_ </span><span class="s2">and </span><span class="s1">pkg_prefix / </span><span class="s3">&quot;__init__.py&quot; </span><span class="s1">!= path</span>
                <span class="s2">for </span><span class="s1">pkg_prefix </span><span class="s2">in </span><span class="s1">pkg_prefixes</span>
            <span class="s1">):</span>
                <span class="s2">continue</span>

            <span class="s2">if </span><span class="s1">direntry.is_file():</span>
                <span class="s2">yield from </span><span class="s1">self._collectfile(path)</span>
            <span class="s2">elif not </span><span class="s1">direntry.is_dir():</span>
                <span class="s4"># Broken symlink or invalid/missing file.</span>
                <span class="s2">continue</span>
            <span class="s2">elif </span><span class="s1">path.joinpath(</span><span class="s3">&quot;__init__.py&quot;</span><span class="s1">).is_file():</span>
                <span class="s1">pkg_prefixes.add(path)</span>


<span class="s2">def </span><span class="s1">_call_with_optional_argument(func</span><span class="s2">, </span><span class="s1">arg) -&gt; </span><span class="s2">None</span><span class="s1">:</span>
    <span class="s0">&quot;&quot;&quot;Call the given function with the given argument if func accepts one argument, otherwise 
    calls func without arguments.&quot;&quot;&quot;</span>
    <span class="s1">arg_count = func.__code__.co_argcount</span>
    <span class="s2">if </span><span class="s1">inspect.ismethod(func):</span>
        <span class="s1">arg_count -= </span><span class="s5">1</span>
    <span class="s2">if </span><span class="s1">arg_count:</span>
        <span class="s1">func(arg)</span>
    <span class="s2">else</span><span class="s1">:</span>
        <span class="s1">func()</span>


<span class="s2">def </span><span class="s1">_get_first_non_fixture_func(obj: object</span><span class="s2">, </span><span class="s1">names: Iterable[str]) -&gt; Optional[object]:</span>
    <span class="s0">&quot;&quot;&quot;Return the attribute from the given object to be used as a setup/teardown 
    xunit-style function, but only if not marked as a fixture to avoid calling it twice.&quot;&quot;&quot;</span>
    <span class="s2">for </span><span class="s1">name </span><span class="s2">in </span><span class="s1">names:</span>
        <span class="s1">meth: Optional[object] = getattr(obj</span><span class="s2">, </span><span class="s1">name</span><span class="s2">, None</span><span class="s1">)</span>
        <span class="s2">if </span><span class="s1">meth </span><span class="s2">is not None and </span><span class="s1">fixtures.getfixturemarker(meth) </span><span class="s2">is None</span><span class="s1">:</span>
            <span class="s2">return </span><span class="s1">meth</span>
    <span class="s2">return None</span>


<span class="s2">class </span><span class="s1">Class(PyCollector):</span>
    <span class="s0">&quot;&quot;&quot;Collector for test methods.&quot;&quot;&quot;</span>

    <span class="s1">@classmethod</span>
    <span class="s2">def </span><span class="s1">from_parent(cls</span><span class="s2">, </span><span class="s1">parent</span><span class="s2">, </span><span class="s1">*</span><span class="s2">, </span><span class="s1">name</span><span class="s2">, </span><span class="s1">obj=</span><span class="s2">None, </span><span class="s1">**kw):</span>
        <span class="s0">&quot;&quot;&quot;The public constructor.&quot;&quot;&quot;</span>
        <span class="s2">return </span><span class="s1">super().from_parent(name=name</span><span class="s2">, </span><span class="s1">parent=parent</span><span class="s2">, </span><span class="s1">**kw)</span>

    <span class="s2">def </span><span class="s1">newinstance(self):</span>
        <span class="s2">return </span><span class="s1">self.obj()</span>

    <span class="s2">def </span><span class="s1">collect(self) -&gt; Iterable[Union[nodes.Item</span><span class="s2">, </span><span class="s1">nodes.Collector]]:</span>
        <span class="s2">if not </span><span class="s1">safe_getattr(self.obj</span><span class="s2">, </span><span class="s3">&quot;__test__&quot;</span><span class="s2">, True</span><span class="s1">):</span>
            <span class="s2">return </span><span class="s1">[]</span>
        <span class="s2">if </span><span class="s1">hasinit(self.obj):</span>
            <span class="s2">assert </span><span class="s1">self.parent </span><span class="s2">is not None</span>
            <span class="s1">self.warn(</span>
                <span class="s1">PytestCollectionWarning(</span>
                    <span class="s3">&quot;cannot collect test class %r because it has a &quot;</span>
                    <span class="s3">&quot;__init__ constructor (from: %s)&quot;</span>
                    <span class="s1">% (self.obj.__name__</span><span class="s2">, </span><span class="s1">self.parent.nodeid)</span>
                <span class="s1">)</span>
            <span class="s1">)</span>
            <span class="s2">return </span><span class="s1">[]</span>
        <span class="s2">elif </span><span class="s1">hasnew(self.obj):</span>
            <span class="s2">assert </span><span class="s1">self.parent </span><span class="s2">is not None</span>
            <span class="s1">self.warn(</span>
                <span class="s1">PytestCollectionWarning(</span>
                    <span class="s3">&quot;cannot collect test class %r because it has a &quot;</span>
                    <span class="s3">&quot;__new__ constructor (from: %s)&quot;</span>
                    <span class="s1">% (self.obj.__name__</span><span class="s2">, </span><span class="s1">self.parent.nodeid)</span>
                <span class="s1">)</span>
            <span class="s1">)</span>
            <span class="s2">return </span><span class="s1">[]</span>

        <span class="s1">self._inject_setup_class_fixture()</span>
        <span class="s1">self._inject_setup_method_fixture()</span>

        <span class="s1">self.session._fixturemanager.parsefactories(self.newinstance()</span><span class="s2">, </span><span class="s1">self.nodeid)</span>

        <span class="s2">return </span><span class="s1">super().collect()</span>

    <span class="s2">def </span><span class="s1">_inject_setup_class_fixture(self) -&gt; </span><span class="s2">None</span><span class="s1">:</span>
        <span class="s0">&quot;&quot;&quot;Inject a hidden autouse, class scoped fixture into the collected class object 
        that invokes setup_class/teardown_class if either or both are available. 
 
        Using a fixture to invoke this methods ensures we play nicely and unsurprisingly with 
        other fixtures (#517). 
        &quot;&quot;&quot;</span>
        <span class="s1">setup_class = _get_first_non_fixture_func(self.obj</span><span class="s2">, </span><span class="s1">(</span><span class="s3">&quot;setup_class&quot;</span><span class="s2">,</span><span class="s1">))</span>
        <span class="s1">teardown_class = getattr(self.obj</span><span class="s2">, </span><span class="s3">&quot;teardown_class&quot;</span><span class="s2">, None</span><span class="s1">)</span>
        <span class="s2">if </span><span class="s1">setup_class </span><span class="s2">is None and </span><span class="s1">teardown_class </span><span class="s2">is None</span><span class="s1">:</span>
            <span class="s2">return</span>

        <span class="s1">@fixtures.fixture(</span>
            <span class="s1">autouse=</span><span class="s2">True,</span>
            <span class="s1">scope=</span><span class="s3">&quot;class&quot;</span><span class="s2">,</span>
            <span class="s4"># Use a unique name to speed up lookup.</span>
            <span class="s1">name=</span><span class="s3">f&quot;_xunit_setup_class_fixture_</span><span class="s2">{</span><span class="s1">self.obj.__qualname__</span><span class="s2">}</span><span class="s3">&quot;</span><span class="s2">,</span>
        <span class="s1">)</span>
        <span class="s2">def </span><span class="s1">xunit_setup_class_fixture(cls) -&gt; Generator[</span><span class="s2">None, None, None</span><span class="s1">]:</span>
            <span class="s2">if </span><span class="s1">setup_class </span><span class="s2">is not None</span><span class="s1">:</span>
                <span class="s1">func = getimfunc(setup_class)</span>
                <span class="s1">_call_with_optional_argument(func</span><span class="s2">, </span><span class="s1">self.obj)</span>
            <span class="s2">yield</span>
            <span class="s2">if </span><span class="s1">teardown_class </span><span class="s2">is not None</span><span class="s1">:</span>
                <span class="s1">func = getimfunc(teardown_class)</span>
                <span class="s1">_call_with_optional_argument(func</span><span class="s2">, </span><span class="s1">self.obj)</span>

        <span class="s1">self.obj.__pytest_setup_class = xunit_setup_class_fixture</span>

    <span class="s2">def </span><span class="s1">_inject_setup_method_fixture(self) -&gt; </span><span class="s2">None</span><span class="s1">:</span>
        <span class="s0">&quot;&quot;&quot;Inject a hidden autouse, function scoped fixture into the collected class object 
        that invokes setup_method/teardown_method if either or both are available. 
 
        Using a fixture to invoke this methods ensures we play nicely and unsurprisingly with 
        other fixtures (#517). 
        &quot;&quot;&quot;</span>
        <span class="s1">has_nose = self.config.pluginmanager.has_plugin(</span><span class="s3">&quot;nose&quot;</span><span class="s1">)</span>
        <span class="s1">setup_name = </span><span class="s3">&quot;setup_method&quot;</span>
        <span class="s1">setup_method = _get_first_non_fixture_func(self.obj</span><span class="s2">, </span><span class="s1">(setup_name</span><span class="s2">,</span><span class="s1">))</span>
        <span class="s2">if </span><span class="s1">setup_method </span><span class="s2">is None and </span><span class="s1">has_nose:</span>
            <span class="s1">setup_name = </span><span class="s3">&quot;setup&quot;</span>
            <span class="s1">setup_method = _get_first_non_fixture_func(self.obj</span><span class="s2">, </span><span class="s1">(setup_name</span><span class="s2">,</span><span class="s1">))</span>
        <span class="s1">teardown_name = </span><span class="s3">&quot;teardown_method&quot;</span>
        <span class="s1">teardown_method = getattr(self.obj</span><span class="s2">, </span><span class="s1">teardown_name</span><span class="s2">, None</span><span class="s1">)</span>
        <span class="s2">if </span><span class="s1">teardown_method </span><span class="s2">is None and </span><span class="s1">has_nose:</span>
            <span class="s1">teardown_name = </span><span class="s3">&quot;teardown&quot;</span>
            <span class="s1">teardown_method = getattr(self.obj</span><span class="s2">, </span><span class="s1">teardown_name</span><span class="s2">, None</span><span class="s1">)</span>
        <span class="s2">if </span><span class="s1">setup_method </span><span class="s2">is None and </span><span class="s1">teardown_method </span><span class="s2">is None</span><span class="s1">:</span>
            <span class="s2">return</span>

        <span class="s1">@fixtures.fixture(</span>
            <span class="s1">autouse=</span><span class="s2">True,</span>
            <span class="s1">scope=</span><span class="s3">&quot;function&quot;</span><span class="s2">,</span>
            <span class="s4"># Use a unique name to speed up lookup.</span>
            <span class="s1">name=</span><span class="s3">f&quot;_xunit_setup_method_fixture_</span><span class="s2">{</span><span class="s1">self.obj.__qualname__</span><span class="s2">}</span><span class="s3">&quot;</span><span class="s2">,</span>
        <span class="s1">)</span>
        <span class="s2">def </span><span class="s1">xunit_setup_method_fixture(self</span><span class="s2">, </span><span class="s1">request) -&gt; Generator[</span><span class="s2">None, None, None</span><span class="s1">]:</span>
            <span class="s1">method = request.function</span>
            <span class="s2">if </span><span class="s1">setup_method </span><span class="s2">is not None</span><span class="s1">:</span>
                <span class="s1">func = getattr(self</span><span class="s2">, </span><span class="s1">setup_name)</span>
                <span class="s1">_call_with_optional_argument(func</span><span class="s2">, </span><span class="s1">method)</span>
            <span class="s2">yield</span>
            <span class="s2">if </span><span class="s1">teardown_method </span><span class="s2">is not None</span><span class="s1">:</span>
                <span class="s1">func = getattr(self</span><span class="s2">, </span><span class="s1">teardown_name)</span>
                <span class="s1">_call_with_optional_argument(func</span><span class="s2">, </span><span class="s1">method)</span>

        <span class="s1">self.obj.__pytest_setup_method = xunit_setup_method_fixture</span>


<span class="s2">class </span><span class="s1">InstanceDummy:</span>
    <span class="s0">&quot;&quot;&quot;Instance used to be a node type between Class and Function. It has been 
    removed in pytest 7.0. Some plugins exist which reference `pytest.Instance` 
    only to ignore it; this dummy class keeps them working. This will be removed 
    in pytest 8.&quot;&quot;&quot;</span>


<span class="s2">def </span><span class="s1">__getattr__(name: str) -&gt; object:</span>
    <span class="s2">if </span><span class="s1">name == </span><span class="s3">&quot;Instance&quot;</span><span class="s1">:</span>
        <span class="s1">warnings.warn(INSTANCE_COLLECTOR</span><span class="s2">, </span><span class="s5">2</span><span class="s1">)</span>
        <span class="s2">return </span><span class="s1">InstanceDummy</span>
    <span class="s2">raise </span><span class="s1">AttributeError(</span><span class="s3">f&quot;module </span><span class="s2">{</span><span class="s1">__name__</span><span class="s2">} </span><span class="s3">has no attribute </span><span class="s2">{</span><span class="s1">name</span><span class="s2">}</span><span class="s3">&quot;</span><span class="s1">)</span>


<span class="s2">def </span><span class="s1">hasinit(obj: object) -&gt; bool:</span>
    <span class="s1">init: object = getattr(obj</span><span class="s2">, </span><span class="s3">&quot;__init__&quot;</span><span class="s2">, None</span><span class="s1">)</span>
    <span class="s2">if </span><span class="s1">init:</span>
        <span class="s2">return </span><span class="s1">init != object.__init__</span>
    <span class="s2">return False</span>


<span class="s2">def </span><span class="s1">hasnew(obj: object) -&gt; bool:</span>
    <span class="s1">new: object = getattr(obj</span><span class="s2">, </span><span class="s3">&quot;__new__&quot;</span><span class="s2">, None</span><span class="s1">)</span>
    <span class="s2">if </span><span class="s1">new:</span>
        <span class="s2">return </span><span class="s1">new != object.__new__</span>
    <span class="s2">return False</span>


<span class="s1">@final</span>
<span class="s1">@attr.s(frozen=</span><span class="s2">True, </span><span class="s1">auto_attribs=</span><span class="s2">True, </span><span class="s1">slots=</span><span class="s2">True</span><span class="s1">)</span>
<span class="s2">class </span><span class="s1">IdMaker:</span>
    <span class="s0">&quot;&quot;&quot;Make IDs for a parametrization.&quot;&quot;&quot;</span>

    <span class="s4"># The argnames of the parametrization.</span>
    <span class="s1">argnames: Sequence[str]</span>
    <span class="s4"># The ParameterSets of the parametrization.</span>
    <span class="s1">parametersets: Sequence[ParameterSet]</span>
    <span class="s4"># Optionally, a user-provided callable to make IDs for parameters in a</span>
    <span class="s4"># ParameterSet.</span>
    <span class="s1">idfn: Optional[Callable[[Any]</span><span class="s2">, </span><span class="s1">Optional[object]]]</span>
    <span class="s4"># Optionally, explicit IDs for ParameterSets by index.</span>
    <span class="s1">ids: Optional[Sequence[Optional[object]]]</span>
    <span class="s4"># Optionally, the pytest config.</span>
    <span class="s4"># Used for controlling ASCII escaping, and for calling the</span>
    <span class="s4"># :hook:`pytest_make_parametrize_id` hook.</span>
    <span class="s1">config: Optional[Config]</span>
    <span class="s4"># Optionally, the ID of the node being parametrized.</span>
    <span class="s4"># Used only for clearer error messages.</span>
    <span class="s1">nodeid: Optional[str]</span>
    <span class="s4"># Optionally, the ID of the function being parametrized.</span>
    <span class="s4"># Used only for clearer error messages.</span>
    <span class="s1">func_name: Optional[str]</span>

    <span class="s2">def </span><span class="s1">make_unique_parameterset_ids(self) -&gt; List[str]:</span>
        <span class="s0">&quot;&quot;&quot;Make a unique identifier for each ParameterSet, that may be used to 
        identify the parametrization in a node ID. 
 
        Format is &lt;prm_1_token&gt;-...-&lt;prm_n_token&gt;[counter], where prm_x_token is 
        - user-provided id, if given 
        - else an id derived from the value, applicable for certain types 
        - else &lt;argname&gt;&lt;parameterset index&gt; 
        The counter suffix is appended only in case a string wouldn't be unique 
        otherwise. 
        &quot;&quot;&quot;</span>
        <span class="s1">resolved_ids = list(self._resolve_ids())</span>
        <span class="s4"># All IDs must be unique!</span>
        <span class="s2">if </span><span class="s1">len(resolved_ids) != len(set(resolved_ids)):</span>
            <span class="s4"># Record the number of occurrences of each ID.</span>
            <span class="s1">id_counts = Counter(resolved_ids)</span>
            <span class="s4"># Map the ID to its next suffix.</span>
            <span class="s1">id_suffixes: Dict[str</span><span class="s2">, </span><span class="s1">int] = defaultdict(int)</span>
            <span class="s4"># Suffix non-unique IDs to make them unique.</span>
            <span class="s2">for </span><span class="s1">index</span><span class="s2">, </span><span class="s1">id </span><span class="s2">in </span><span class="s1">enumerate(resolved_ids):</span>
                <span class="s2">if </span><span class="s1">id_counts[id] &gt; </span><span class="s5">1</span><span class="s1">:</span>
                    <span class="s1">resolved_ids[index] = </span><span class="s3">f&quot;</span><span class="s2">{</span><span class="s1">id</span><span class="s2">}{</span><span class="s1">id_suffixes[id]</span><span class="s2">}</span><span class="s3">&quot;</span>
                    <span class="s1">id_suffixes[id] += </span><span class="s5">1</span>
        <span class="s2">return </span><span class="s1">resolved_ids</span>

    <span class="s2">def </span><span class="s1">_resolve_ids(self) -&gt; Iterable[str]:</span>
        <span class="s0">&quot;&quot;&quot;Resolve IDs for all ParameterSets (may contain duplicates).&quot;&quot;&quot;</span>
        <span class="s2">for </span><span class="s1">idx</span><span class="s2">, </span><span class="s1">parameterset </span><span class="s2">in </span><span class="s1">enumerate(self.parametersets):</span>
            <span class="s2">if </span><span class="s1">parameterset.id </span><span class="s2">is not None</span><span class="s1">:</span>
                <span class="s4"># ID provided directly - pytest.param(..., id=&quot;...&quot;)</span>
                <span class="s2">yield </span><span class="s1">parameterset.id</span>
            <span class="s2">elif </span><span class="s1">self.ids </span><span class="s2">and </span><span class="s1">idx &lt; len(self.ids) </span><span class="s2">and </span><span class="s1">self.ids[idx] </span><span class="s2">is not None</span><span class="s1">:</span>
                <span class="s4"># ID provided in the IDs list - parametrize(..., ids=[...]).</span>
                <span class="s2">yield </span><span class="s1">self._idval_from_value_required(self.ids[idx]</span><span class="s2">, </span><span class="s1">idx)</span>
            <span class="s2">else</span><span class="s1">:</span>
                <span class="s4"># ID not provided - generate it.</span>
                <span class="s2">yield </span><span class="s3">&quot;-&quot;</span><span class="s1">.join(</span>
                    <span class="s1">self._idval(val</span><span class="s2">, </span><span class="s1">argname</span><span class="s2">, </span><span class="s1">idx)</span>
                    <span class="s2">for </span><span class="s1">val</span><span class="s2">, </span><span class="s1">argname </span><span class="s2">in </span><span class="s1">zip(parameterset.values</span><span class="s2">, </span><span class="s1">self.argnames)</span>
                <span class="s1">)</span>

    <span class="s2">def </span><span class="s1">_idval(self</span><span class="s2">, </span><span class="s1">val: object</span><span class="s2">, </span><span class="s1">argname: str</span><span class="s2">, </span><span class="s1">idx: int) -&gt; str:</span>
        <span class="s0">&quot;&quot;&quot;Make an ID for a parameter in a ParameterSet.&quot;&quot;&quot;</span>
        <span class="s1">idval = self._idval_from_function(val</span><span class="s2">, </span><span class="s1">argname</span><span class="s2">, </span><span class="s1">idx)</span>
        <span class="s2">if </span><span class="s1">idval </span><span class="s2">is not None</span><span class="s1">:</span>
            <span class="s2">return </span><span class="s1">idval</span>
        <span class="s1">idval = self._idval_from_hook(val</span><span class="s2">, </span><span class="s1">argname)</span>
        <span class="s2">if </span><span class="s1">idval </span><span class="s2">is not None</span><span class="s1">:</span>
            <span class="s2">return </span><span class="s1">idval</span>
        <span class="s1">idval = self._idval_from_value(val)</span>
        <span class="s2">if </span><span class="s1">idval </span><span class="s2">is not None</span><span class="s1">:</span>
            <span class="s2">return </span><span class="s1">idval</span>
        <span class="s2">return </span><span class="s1">self._idval_from_argname(argname</span><span class="s2">, </span><span class="s1">idx)</span>

    <span class="s2">def </span><span class="s1">_idval_from_function(</span>
        <span class="s1">self</span><span class="s2">, </span><span class="s1">val: object</span><span class="s2">, </span><span class="s1">argname: str</span><span class="s2">, </span><span class="s1">idx: int</span>
    <span class="s1">) -&gt; Optional[str]:</span>
        <span class="s0">&quot;&quot;&quot;Try to make an ID for a parameter in a ParameterSet using the 
        user-provided id callable, if given.&quot;&quot;&quot;</span>
        <span class="s2">if </span><span class="s1">self.idfn </span><span class="s2">is None</span><span class="s1">:</span>
            <span class="s2">return None</span>
        <span class="s2">try</span><span class="s1">:</span>
            <span class="s1">id = self.idfn(val)</span>
        <span class="s2">except </span><span class="s1">Exception </span><span class="s2">as </span><span class="s1">e:</span>
            <span class="s1">prefix = </span><span class="s3">f&quot;</span><span class="s2">{</span><span class="s1">self.nodeid</span><span class="s2">}</span><span class="s3">: &quot; </span><span class="s2">if </span><span class="s1">self.nodeid </span><span class="s2">is not None else </span><span class="s3">&quot;&quot;</span>
            <span class="s1">msg = </span><span class="s3">&quot;error raised while trying to determine id of parameter '{}' at position {}&quot;</span>
            <span class="s1">msg = prefix + msg.format(argname</span><span class="s2">, </span><span class="s1">idx)</span>
            <span class="s2">raise </span><span class="s1">ValueError(msg) </span><span class="s2">from </span><span class="s1">e</span>
        <span class="s2">if </span><span class="s1">id </span><span class="s2">is None</span><span class="s1">:</span>
            <span class="s2">return None</span>
        <span class="s2">return </span><span class="s1">self._idval_from_value(id)</span>

    <span class="s2">def </span><span class="s1">_idval_from_hook(self</span><span class="s2">, </span><span class="s1">val: object</span><span class="s2">, </span><span class="s1">argname: str) -&gt; Optional[str]:</span>
        <span class="s0">&quot;&quot;&quot;Try to make an ID for a parameter in a ParameterSet by calling the 
        :hook:`pytest_make_parametrize_id` hook.&quot;&quot;&quot;</span>
        <span class="s2">if </span><span class="s1">self.config:</span>
            <span class="s1">id: Optional[str] = self.config.hook.pytest_make_parametrize_id(</span>
                <span class="s1">config=self.config</span><span class="s2">, </span><span class="s1">val=val</span><span class="s2">, </span><span class="s1">argname=argname</span>
            <span class="s1">)</span>
            <span class="s2">return </span><span class="s1">id</span>
        <span class="s2">return None</span>

    <span class="s2">def </span><span class="s1">_idval_from_value(self</span><span class="s2">, </span><span class="s1">val: object) -&gt; Optional[str]:</span>
        <span class="s0">&quot;&quot;&quot;Try to make an ID for a parameter in a ParameterSet from its value, 
        if the value type is supported.&quot;&quot;&quot;</span>
        <span class="s2">if </span><span class="s1">isinstance(val</span><span class="s2">, </span><span class="s1">STRING_TYPES):</span>
            <span class="s2">return </span><span class="s1">_ascii_escaped_by_config(val</span><span class="s2">, </span><span class="s1">self.config)</span>
        <span class="s2">elif </span><span class="s1">val </span><span class="s2">is None or </span><span class="s1">isinstance(val</span><span class="s2">, </span><span class="s1">(float</span><span class="s2">, </span><span class="s1">int</span><span class="s2">, </span><span class="s1">bool</span><span class="s2">, </span><span class="s1">complex)):</span>
            <span class="s2">return </span><span class="s1">str(val)</span>
        <span class="s2">elif </span><span class="s1">isinstance(val</span><span class="s2">, </span><span class="s1">Pattern):</span>
            <span class="s2">return </span><span class="s1">ascii_escaped(val.pattern)</span>
        <span class="s2">elif </span><span class="s1">val </span><span class="s2">is </span><span class="s1">NOTSET:</span>
            <span class="s4"># Fallback to default. Note that NOTSET is an enum.Enum.</span>
            <span class="s2">pass</span>
        <span class="s2">elif </span><span class="s1">isinstance(val</span><span class="s2">, </span><span class="s1">enum.Enum):</span>
            <span class="s2">return </span><span class="s1">str(val)</span>
        <span class="s2">elif </span><span class="s1">isinstance(getattr(val</span><span class="s2">, </span><span class="s3">&quot;__name__&quot;</span><span class="s2">, None</span><span class="s1">)</span><span class="s2">, </span><span class="s1">str):</span>
            <span class="s4"># Name of a class, function, module, etc.</span>
            <span class="s1">name: str = getattr(val</span><span class="s2">, </span><span class="s3">&quot;__name__&quot;</span><span class="s1">)</span>
            <span class="s2">return </span><span class="s1">name</span>
        <span class="s2">return None</span>

    <span class="s2">def </span><span class="s1">_idval_from_value_required(self</span><span class="s2">, </span><span class="s1">val: object</span><span class="s2">, </span><span class="s1">idx: int) -&gt; str:</span>
        <span class="s0">&quot;&quot;&quot;Like _idval_from_value(), but fails if the type is not supported.&quot;&quot;&quot;</span>
        <span class="s1">id = self._idval_from_value(val)</span>
        <span class="s2">if </span><span class="s1">id </span><span class="s2">is not None</span><span class="s1">:</span>
            <span class="s2">return </span><span class="s1">id</span>

        <span class="s4"># Fail.</span>
        <span class="s2">if </span><span class="s1">self.func_name </span><span class="s2">is not None</span><span class="s1">:</span>
            <span class="s1">prefix = </span><span class="s3">f&quot;In </span><span class="s2">{</span><span class="s1">self.func_name</span><span class="s2">}</span><span class="s3">: &quot;</span>
        <span class="s2">elif </span><span class="s1">self.nodeid </span><span class="s2">is not None</span><span class="s1">:</span>
            <span class="s1">prefix = </span><span class="s3">f&quot;In </span><span class="s2">{</span><span class="s1">self.nodeid</span><span class="s2">}</span><span class="s3">: &quot;</span>
        <span class="s2">else</span><span class="s1">:</span>
            <span class="s1">prefix = </span><span class="s3">&quot;&quot;</span>
        <span class="s1">msg = (</span>
            <span class="s3">f&quot;</span><span class="s2">{</span><span class="s1">prefix</span><span class="s2">}</span><span class="s3">ids contains unsupported value </span><span class="s2">{</span><span class="s1">saferepr(val)</span><span class="s2">} </span><span class="s3">(type: </span><span class="s2">{</span><span class="s1">type(val)</span><span class="s2">!r}</span><span class="s3">) at index </span><span class="s2">{</span><span class="s1">idx</span><span class="s2">}</span><span class="s3">. &quot;</span>
            <span class="s3">&quot;Supported types are: str, bytes, int, float, complex, bool, enum, regex or anything with a __name__.&quot;</span>
        <span class="s1">)</span>
        <span class="s1">fail(msg</span><span class="s2">, </span><span class="s1">pytrace=</span><span class="s2">False</span><span class="s1">)</span>

    <span class="s1">@staticmethod</span>
    <span class="s2">def </span><span class="s1">_idval_from_argname(argname: str</span><span class="s2">, </span><span class="s1">idx: int) -&gt; str:</span>
        <span class="s0">&quot;&quot;&quot;Make an ID for a parameter in a ParameterSet from the argument name 
        and the index of the ParameterSet.&quot;&quot;&quot;</span>
        <span class="s2">return </span><span class="s1">str(argname) + str(idx)</span>


<span class="s1">@final</span>
<span class="s1">@attr.s(frozen=</span><span class="s2">True, </span><span class="s1">slots=</span><span class="s2">True, </span><span class="s1">auto_attribs=</span><span class="s2">True</span><span class="s1">)</span>
<span class="s2">class </span><span class="s1">CallSpec2:</span>
    <span class="s0">&quot;&quot;&quot;A planned parameterized invocation of a test function. 
 
    Calculated during collection for a given test function's Metafunc. 
    Once collection is over, each callspec is turned into a single Item 
    and stored in item.callspec. 
    &quot;&quot;&quot;</span>

    <span class="s4"># arg name -&gt; arg value which will be passed to the parametrized test</span>
    <span class="s4"># function (direct parameterization).</span>
    <span class="s1">funcargs: Dict[str</span><span class="s2">, </span><span class="s1">object] = attr.Factory(dict)</span>
    <span class="s4"># arg name -&gt; arg value which will be passed to a fixture of the same name</span>
    <span class="s4"># (indirect parametrization).</span>
    <span class="s1">params: Dict[str</span><span class="s2">, </span><span class="s1">object] = attr.Factory(dict)</span>
    <span class="s4"># arg name -&gt; arg index.</span>
    <span class="s1">indices: Dict[str</span><span class="s2">, </span><span class="s1">int] = attr.Factory(dict)</span>
    <span class="s4"># Used for sorting parametrized resources.</span>
    <span class="s1">_arg2scope: Dict[str</span><span class="s2">, </span><span class="s1">Scope] = attr.Factory(dict)</span>
    <span class="s4"># Parts which will be added to the item's name in `[..]` separated by &quot;-&quot;.</span>
    <span class="s1">_idlist: List[str] = attr.Factory(list)</span>
    <span class="s4"># Marks which will be applied to the item.</span>
    <span class="s1">marks: List[Mark] = attr.Factory(list)</span>

    <span class="s2">def </span><span class="s1">setmulti(</span>
        <span class="s1">self</span><span class="s2">,</span>
        <span class="s1">*</span><span class="s2">,</span>
        <span class="s1">valtypes: Mapping[str</span><span class="s2">, </span><span class="s3">&quot;Literal['params', 'funcargs']&quot;</span><span class="s1">]</span><span class="s2">,</span>
        <span class="s1">argnames: Iterable[str]</span><span class="s2">,</span>
        <span class="s1">valset: Iterable[object]</span><span class="s2">,</span>
        <span class="s1">id: str</span><span class="s2">,</span>
        <span class="s1">marks: Iterable[Union[Mark</span><span class="s2">, </span><span class="s1">MarkDecorator]]</span><span class="s2">,</span>
        <span class="s1">scope: Scope</span><span class="s2">,</span>
        <span class="s1">param_index: int</span><span class="s2">,</span>
    <span class="s1">) -&gt; </span><span class="s3">&quot;CallSpec2&quot;</span><span class="s1">:</span>
        <span class="s1">funcargs = self.funcargs.copy()</span>
        <span class="s1">params = self.params.copy()</span>
        <span class="s1">indices = self.indices.copy()</span>
        <span class="s1">arg2scope = self._arg2scope.copy()</span>
        <span class="s2">for </span><span class="s1">arg</span><span class="s2">, </span><span class="s1">val </span><span class="s2">in </span><span class="s1">zip(argnames</span><span class="s2">, </span><span class="s1">valset):</span>
            <span class="s2">if </span><span class="s1">arg </span><span class="s2">in </span><span class="s1">params </span><span class="s2">or </span><span class="s1">arg </span><span class="s2">in </span><span class="s1">funcargs:</span>
                <span class="s2">raise </span><span class="s1">ValueError(</span><span class="s3">f&quot;duplicate </span><span class="s2">{</span><span class="s1">arg</span><span class="s2">!r}</span><span class="s3">&quot;</span><span class="s1">)</span>
            <span class="s1">valtype_for_arg = valtypes[arg]</span>
            <span class="s2">if </span><span class="s1">valtype_for_arg == </span><span class="s3">&quot;params&quot;</span><span class="s1">:</span>
                <span class="s1">params[arg] = val</span>
            <span class="s2">elif </span><span class="s1">valtype_for_arg == </span><span class="s3">&quot;funcargs&quot;</span><span class="s1">:</span>
                <span class="s1">funcargs[arg] = val</span>
            <span class="s2">else</span><span class="s1">:</span>
                <span class="s1">assert_never(valtype_for_arg)</span>
            <span class="s1">indices[arg] = param_index</span>
            <span class="s1">arg2scope[arg] = scope</span>
        <span class="s2">return </span><span class="s1">CallSpec2(</span>
            <span class="s1">funcargs=funcargs</span><span class="s2">,</span>
            <span class="s1">params=params</span><span class="s2">,</span>
            <span class="s1">arg2scope=arg2scope</span><span class="s2">,</span>
            <span class="s1">indices=indices</span><span class="s2">,</span>
            <span class="s1">idlist=[*self._idlist</span><span class="s2">, </span><span class="s1">id]</span><span class="s2">,</span>
            <span class="s1">marks=[*self.marks</span><span class="s2">, </span><span class="s1">*normalize_mark_list(marks)]</span><span class="s2">,</span>
        <span class="s1">)</span>

    <span class="s2">def </span><span class="s1">getparam(self</span><span class="s2">, </span><span class="s1">name: str) -&gt; object:</span>
        <span class="s2">try</span><span class="s1">:</span>
            <span class="s2">return </span><span class="s1">self.params[name]</span>
        <span class="s2">except </span><span class="s1">KeyError </span><span class="s2">as </span><span class="s1">e:</span>
            <span class="s2">raise </span><span class="s1">ValueError(name) </span><span class="s2">from </span><span class="s1">e</span>

    <span class="s1">@property</span>
    <span class="s2">def </span><span class="s1">id(self) -&gt; str:</span>
        <span class="s2">return </span><span class="s3">&quot;-&quot;</span><span class="s1">.join(self._idlist)</span>


<span class="s1">@final</span>
<span class="s2">class </span><span class="s1">Metafunc:</span>
    <span class="s0">&quot;&quot;&quot;Objects passed to the :hook:`pytest_generate_tests` hook. 
 
    They help to inspect a test function and to generate tests according to 
    test configuration or values specified in the class or module where a 
    test function is defined. 
    &quot;&quot;&quot;</span>

    <span class="s2">def </span><span class="s1">__init__(</span>
        <span class="s1">self</span><span class="s2">,</span>
        <span class="s1">definition: </span><span class="s3">&quot;FunctionDefinition&quot;</span><span class="s2">,</span>
        <span class="s1">fixtureinfo: fixtures.FuncFixtureInfo</span><span class="s2">,</span>
        <span class="s1">config: Config</span><span class="s2">,</span>
        <span class="s1">cls=</span><span class="s2">None,</span>
        <span class="s1">module=</span><span class="s2">None,</span>
        <span class="s1">*</span><span class="s2">,</span>
        <span class="s1">_ispytest: bool = </span><span class="s2">False,</span>
    <span class="s1">) -&gt; </span><span class="s2">None</span><span class="s1">:</span>
        <span class="s1">check_ispytest(_ispytest)</span>

        <span class="s4">#: Access to the underlying :class:`_pytest.python.FunctionDefinition`.</span>
        <span class="s1">self.definition = definition</span>

        <span class="s4">#: Access to the :class:`pytest.Config` object for the test session.</span>
        <span class="s1">self.config = config</span>

        <span class="s4">#: The module object where the test function is defined in.</span>
        <span class="s1">self.module = module</span>

        <span class="s4">#: Underlying Python test function.</span>
        <span class="s1">self.function = definition.obj</span>

        <span class="s4">#: Set of fixture names required by the test function.</span>
        <span class="s1">self.fixturenames = fixtureinfo.names_closure</span>

        <span class="s4">#: Class object where the test function is defined in or ``None``.</span>
        <span class="s1">self.cls = cls</span>

        <span class="s1">self._arg2fixturedefs = fixtureinfo.name2fixturedefs</span>

        <span class="s4"># Result of parametrize().</span>
        <span class="s1">self._calls: List[CallSpec2] = []</span>

    <span class="s2">def </span><span class="s1">parametrize(</span>
        <span class="s1">self</span><span class="s2">,</span>
        <span class="s1">argnames: Union[str</span><span class="s2">, </span><span class="s1">List[str]</span><span class="s2">, </span><span class="s1">Tuple[str</span><span class="s2">, </span><span class="s1">...]]</span><span class="s2">,</span>
        <span class="s1">argvalues: Iterable[Union[ParameterSet</span><span class="s2">, </span><span class="s1">Sequence[object]</span><span class="s2">, </span><span class="s1">object]]</span><span class="s2">,</span>
        <span class="s1">indirect: Union[bool</span><span class="s2">, </span><span class="s1">Sequence[str]] = </span><span class="s2">False,</span>
        <span class="s1">ids: Optional[</span>
            <span class="s1">Union[Iterable[Optional[object]]</span><span class="s2">, </span><span class="s1">Callable[[Any]</span><span class="s2">, </span><span class="s1">Optional[object]]]</span>
        <span class="s1">] = </span><span class="s2">None,</span>
        <span class="s1">scope: </span><span class="s3">&quot;Optional[_ScopeName]&quot; </span><span class="s1">= </span><span class="s2">None,</span>
        <span class="s1">*</span><span class="s2">,</span>
        <span class="s1">_param_mark: Optional[Mark] = </span><span class="s2">None,</span>
    <span class="s1">) -&gt; </span><span class="s2">None</span><span class="s1">:</span>
        <span class="s0">&quot;&quot;&quot;Add new invocations to the underlying test function using the list 
        of argvalues for the given argnames. Parametrization is performed 
        during the collection phase. If you need to setup expensive resources 
        see about setting indirect to do it rather than at test setup time. 
 
        Can be called multiple times, in which case each call parametrizes all 
        previous parametrizations, e.g. 
 
        :: 
 
            unparametrized:         t 
            parametrize [&quot;x&quot;, &quot;y&quot;]: t[x], t[y] 
            parametrize [1, 2]:     t[x-1], t[x-2], t[y-1], t[y-2] 
 
        :param argnames: 
            A comma-separated string denoting one or more argument names, or 
            a list/tuple of argument strings. 
 
        :param argvalues: 
            The list of argvalues determines how often a test is invoked with 
            different argument values. 
 
            If only one argname was specified argvalues is a list of values. 
            If N argnames were specified, argvalues must be a list of 
            N-tuples, where each tuple-element specifies a value for its 
            respective argname. 
 
        :param indirect: 
            A list of arguments' names (subset of argnames) or a boolean. 
            If True the list contains all names from the argnames. Each 
            argvalue corresponding to an argname in this list will 
            be passed as request.param to its respective argname fixture 
            function so that it can perform more expensive setups during the 
            setup phase of a test rather than at collection time. 
 
        :param ids: 
            Sequence of (or generator for) ids for ``argvalues``, 
            or a callable to return part of the id for each argvalue. 
 
            With sequences (and generators like ``itertools.count()``) the 
            returned ids should be of type ``string``, ``int``, ``float``, 
            ``bool``, or ``None``. 
            They are mapped to the corresponding index in ``argvalues``. 
            ``None`` means to use the auto-generated id. 
 
            If it is a callable it will be called for each entry in 
            ``argvalues``, and the return value is used as part of the 
            auto-generated id for the whole set (where parts are joined with 
            dashes (&quot;-&quot;)). 
            This is useful to provide more specific ids for certain items, e.g. 
            dates.  Returning ``None`` will use an auto-generated id. 
 
            If no ids are provided they will be generated automatically from 
            the argvalues. 
 
        :param scope: 
            If specified it denotes the scope of the parameters. 
            The scope is used for grouping tests by parameter instances. 
            It will also override any fixture-function defined scope, allowing 
            to set a dynamic scope using test context or configuration. 
        &quot;&quot;&quot;</span>
        <span class="s1">argnames</span><span class="s2">, </span><span class="s1">parametersets = ParameterSet._for_parametrize(</span>
            <span class="s1">argnames</span><span class="s2">,</span>
            <span class="s1">argvalues</span><span class="s2">,</span>
            <span class="s1">self.function</span><span class="s2">,</span>
            <span class="s1">self.config</span><span class="s2">,</span>
            <span class="s1">nodeid=self.definition.nodeid</span><span class="s2">,</span>
        <span class="s1">)</span>
        <span class="s2">del </span><span class="s1">argvalues</span>

        <span class="s2">if </span><span class="s3">&quot;request&quot; </span><span class="s2">in </span><span class="s1">argnames:</span>
            <span class="s1">fail(</span>
                <span class="s3">&quot;'request' is a reserved name and cannot be used in @pytest.mark.parametrize&quot;</span><span class="s2">,</span>
                <span class="s1">pytrace=</span><span class="s2">False,</span>
            <span class="s1">)</span>

        <span class="s2">if </span><span class="s1">scope </span><span class="s2">is not None</span><span class="s1">:</span>
            <span class="s1">scope_ = Scope.from_user(</span>
                <span class="s1">scope</span><span class="s2">, </span><span class="s1">descr=</span><span class="s3">f&quot;parametrize() call in </span><span class="s2">{</span><span class="s1">self.function.__name__</span><span class="s2">}</span><span class="s3">&quot;</span>
            <span class="s1">)</span>
        <span class="s2">else</span><span class="s1">:</span>
            <span class="s1">scope_ = _find_parametrized_scope(argnames</span><span class="s2">, </span><span class="s1">self._arg2fixturedefs</span><span class="s2">, </span><span class="s1">indirect)</span>

        <span class="s1">self._validate_if_using_arg_names(argnames</span><span class="s2">, </span><span class="s1">indirect)</span>

        <span class="s1">arg_values_types = self._resolve_arg_value_types(argnames</span><span class="s2">, </span><span class="s1">indirect)</span>

        <span class="s4"># Use any already (possibly) generated ids with parametrize Marks.</span>
        <span class="s2">if </span><span class="s1">_param_mark </span><span class="s2">and </span><span class="s1">_param_mark._param_ids_from:</span>
            <span class="s1">generated_ids = _param_mark._param_ids_from._param_ids_generated</span>
            <span class="s2">if </span><span class="s1">generated_ids </span><span class="s2">is not None</span><span class="s1">:</span>
                <span class="s1">ids = generated_ids</span>

        <span class="s1">ids = self._resolve_parameter_set_ids(</span>
            <span class="s1">argnames</span><span class="s2">, </span><span class="s1">ids</span><span class="s2">, </span><span class="s1">parametersets</span><span class="s2">, </span><span class="s1">nodeid=self.definition.nodeid</span>
        <span class="s1">)</span>

        <span class="s4"># Store used (possibly generated) ids with parametrize Marks.</span>
        <span class="s2">if </span><span class="s1">_param_mark </span><span class="s2">and </span><span class="s1">_param_mark._param_ids_from </span><span class="s2">and </span><span class="s1">generated_ids </span><span class="s2">is None</span><span class="s1">:</span>
            <span class="s1">object.__setattr__(_param_mark._param_ids_from</span><span class="s2">, </span><span class="s3">&quot;_param_ids_generated&quot;</span><span class="s2">, </span><span class="s1">ids)</span>

        <span class="s4"># Create the new calls: if we are parametrize() multiple times (by applying the decorator</span>
        <span class="s4"># more than once) then we accumulate those calls generating the cartesian product</span>
        <span class="s4"># of all calls.</span>
        <span class="s1">newcalls = []</span>
        <span class="s2">for </span><span class="s1">callspec </span><span class="s2">in </span><span class="s1">self._calls </span><span class="s2">or </span><span class="s1">[CallSpec2()]:</span>
            <span class="s2">for </span><span class="s1">param_index</span><span class="s2">, </span><span class="s1">(param_id</span><span class="s2">, </span><span class="s1">param_set) </span><span class="s2">in </span><span class="s1">enumerate(</span>
                <span class="s1">zip(ids</span><span class="s2">, </span><span class="s1">parametersets)</span>
            <span class="s1">):</span>
                <span class="s1">newcallspec = callspec.setmulti(</span>
                    <span class="s1">valtypes=arg_values_types</span><span class="s2">,</span>
                    <span class="s1">argnames=argnames</span><span class="s2">,</span>
                    <span class="s1">valset=param_set.values</span><span class="s2">,</span>
                    <span class="s1">id=param_id</span><span class="s2">,</span>
                    <span class="s1">marks=param_set.marks</span><span class="s2">,</span>
                    <span class="s1">scope=scope_</span><span class="s2">,</span>
                    <span class="s1">param_index=param_index</span><span class="s2">,</span>
                <span class="s1">)</span>
                <span class="s1">newcalls.append(newcallspec)</span>
        <span class="s1">self._calls = newcalls</span>

    <span class="s2">def </span><span class="s1">_resolve_parameter_set_ids(</span>
        <span class="s1">self</span><span class="s2">,</span>
        <span class="s1">argnames: Sequence[str]</span><span class="s2">,</span>
        <span class="s1">ids: Optional[</span>
            <span class="s1">Union[Iterable[Optional[object]]</span><span class="s2">, </span><span class="s1">Callable[[Any]</span><span class="s2">, </span><span class="s1">Optional[object]]]</span>
        <span class="s1">]</span><span class="s2">,</span>
        <span class="s1">parametersets: Sequence[ParameterSet]</span><span class="s2">,</span>
        <span class="s1">nodeid: str</span><span class="s2">,</span>
    <span class="s1">) -&gt; List[str]:</span>
        <span class="s0">&quot;&quot;&quot;Resolve the actual ids for the given parameter sets. 
 
        :param argnames: 
            Argument names passed to ``parametrize()``. 
        :param ids: 
            The `ids` parameter of the ``parametrize()`` call (see docs). 
        :param parametersets: 
            The parameter sets, each containing a set of values corresponding 
            to ``argnames``. 
        :param nodeid str: 
            The nodeid of the definition item that generated this 
            parametrization. 
        :returns: 
            List with ids for each parameter set given. 
        &quot;&quot;&quot;</span>
        <span class="s2">if </span><span class="s1">ids </span><span class="s2">is None</span><span class="s1">:</span>
            <span class="s1">idfn = </span><span class="s2">None</span>
            <span class="s1">ids_ = </span><span class="s2">None</span>
        <span class="s2">elif </span><span class="s1">callable(ids):</span>
            <span class="s1">idfn = ids</span>
            <span class="s1">ids_ = </span><span class="s2">None</span>
        <span class="s2">else</span><span class="s1">:</span>
            <span class="s1">idfn = </span><span class="s2">None</span>
            <span class="s1">ids_ = self._validate_ids(ids</span><span class="s2">, </span><span class="s1">parametersets</span><span class="s2">, </span><span class="s1">self.function.__name__)</span>
        <span class="s1">id_maker = IdMaker(</span>
            <span class="s1">argnames</span><span class="s2">,</span>
            <span class="s1">parametersets</span><span class="s2">,</span>
            <span class="s1">idfn</span><span class="s2">,</span>
            <span class="s1">ids_</span><span class="s2">,</span>
            <span class="s1">self.config</span><span class="s2">,</span>
            <span class="s1">nodeid=nodeid</span><span class="s2">,</span>
            <span class="s1">func_name=self.function.__name__</span><span class="s2">,</span>
        <span class="s1">)</span>
        <span class="s2">return </span><span class="s1">id_maker.make_unique_parameterset_ids()</span>

    <span class="s2">def </span><span class="s1">_validate_ids(</span>
        <span class="s1">self</span><span class="s2">,</span>
        <span class="s1">ids: Iterable[Optional[object]]</span><span class="s2">,</span>
        <span class="s1">parametersets: Sequence[ParameterSet]</span><span class="s2">,</span>
        <span class="s1">func_name: str</span><span class="s2">,</span>
    <span class="s1">) -&gt; List[Optional[object]]:</span>
        <span class="s2">try</span><span class="s1">:</span>
            <span class="s1">num_ids = len(ids)  </span><span class="s4"># type: ignore[arg-type]</span>
        <span class="s2">except </span><span class="s1">TypeError:</span>
            <span class="s2">try</span><span class="s1">:</span>
                <span class="s1">iter(ids)</span>
            <span class="s2">except </span><span class="s1">TypeError </span><span class="s2">as </span><span class="s1">e:</span>
                <span class="s2">raise </span><span class="s1">TypeError(</span><span class="s3">&quot;ids must be a callable or an iterable&quot;</span><span class="s1">) </span><span class="s2">from </span><span class="s1">e</span>
            <span class="s1">num_ids = len(parametersets)</span>

        <span class="s4"># num_ids == 0 is a special case: https://github.com/pytest-dev/pytest/issues/1849</span>
        <span class="s2">if </span><span class="s1">num_ids != len(parametersets) </span><span class="s2">and </span><span class="s1">num_ids != </span><span class="s5">0</span><span class="s1">:</span>
            <span class="s1">msg = </span><span class="s3">&quot;In {}: {} parameter sets specified, with different number of ids: {}&quot;</span>
            <span class="s1">fail(msg.format(func_name</span><span class="s2">, </span><span class="s1">len(parametersets)</span><span class="s2">, </span><span class="s1">num_ids)</span><span class="s2">, </span><span class="s1">pytrace=</span><span class="s2">False</span><span class="s1">)</span>

        <span class="s2">return </span><span class="s1">list(itertools.islice(ids</span><span class="s2">, </span><span class="s1">num_ids))</span>

    <span class="s2">def </span><span class="s1">_resolve_arg_value_types(</span>
        <span class="s1">self</span><span class="s2">,</span>
        <span class="s1">argnames: Sequence[str]</span><span class="s2">,</span>
        <span class="s1">indirect: Union[bool</span><span class="s2">, </span><span class="s1">Sequence[str]]</span><span class="s2">,</span>
    <span class="s1">) -&gt; Dict[str</span><span class="s2">, </span><span class="s3">&quot;Literal['params', 'funcargs']&quot;</span><span class="s1">]:</span>
        <span class="s0">&quot;&quot;&quot;Resolve if each parametrized argument must be considered a 
        parameter to a fixture or a &quot;funcarg&quot; to the function, based on the 
        ``indirect`` parameter of the parametrized() call. 
 
        :param List[str] argnames: List of argument names passed to ``parametrize()``. 
        :param indirect: Same as the ``indirect`` parameter of ``parametrize()``. 
        :rtype: Dict[str, str] 
            A dict mapping each arg name to either: 
            * &quot;params&quot; if the argname should be the parameter of a fixture of the same name. 
            * &quot;funcargs&quot; if the argname should be a parameter to the parametrized test function. 
        &quot;&quot;&quot;</span>
        <span class="s2">if </span><span class="s1">isinstance(indirect</span><span class="s2">, </span><span class="s1">bool):</span>
            <span class="s1">valtypes: Dict[str</span><span class="s2">, </span><span class="s1">Literal[</span><span class="s3">&quot;params&quot;</span><span class="s2">, </span><span class="s3">&quot;funcargs&quot;</span><span class="s1">]] = dict.fromkeys(</span>
                <span class="s1">argnames</span><span class="s2">, </span><span class="s3">&quot;params&quot; </span><span class="s2">if </span><span class="s1">indirect </span><span class="s2">else </span><span class="s3">&quot;funcargs&quot;</span>
            <span class="s1">)</span>
        <span class="s2">elif </span><span class="s1">isinstance(indirect</span><span class="s2">, </span><span class="s1">Sequence):</span>
            <span class="s1">valtypes = dict.fromkeys(argnames</span><span class="s2">, </span><span class="s3">&quot;funcargs&quot;</span><span class="s1">)</span>
            <span class="s2">for </span><span class="s1">arg </span><span class="s2">in </span><span class="s1">indirect:</span>
                <span class="s2">if </span><span class="s1">arg </span><span class="s2">not in </span><span class="s1">argnames:</span>
                    <span class="s1">fail(</span>
                        <span class="s3">&quot;In {}: indirect fixture '{}' doesn't exist&quot;</span><span class="s1">.format(</span>
                            <span class="s1">self.function.__name__</span><span class="s2">, </span><span class="s1">arg</span>
                        <span class="s1">)</span><span class="s2">,</span>
                        <span class="s1">pytrace=</span><span class="s2">False,</span>
                    <span class="s1">)</span>
                <span class="s1">valtypes[arg] = </span><span class="s3">&quot;params&quot;</span>
        <span class="s2">else</span><span class="s1">:</span>
            <span class="s1">fail(</span>
                <span class="s3">&quot;In {func}: expected Sequence or boolean for indirect, got {type}&quot;</span><span class="s1">.format(</span>
                    <span class="s1">type=type(indirect).__name__</span><span class="s2">, </span><span class="s1">func=self.function.__name__</span>
                <span class="s1">)</span><span class="s2">,</span>
                <span class="s1">pytrace=</span><span class="s2">False,</span>
            <span class="s1">)</span>
        <span class="s2">return </span><span class="s1">valtypes</span>

    <span class="s2">def </span><span class="s1">_validate_if_using_arg_names(</span>
        <span class="s1">self</span><span class="s2">,</span>
        <span class="s1">argnames: Sequence[str]</span><span class="s2">,</span>
        <span class="s1">indirect: Union[bool</span><span class="s2">, </span><span class="s1">Sequence[str]]</span><span class="s2">,</span>
    <span class="s1">) -&gt; </span><span class="s2">None</span><span class="s1">:</span>
        <span class="s0">&quot;&quot;&quot;Check if all argnames are being used, by default values, or directly/indirectly. 
 
        :param List[str] argnames: List of argument names passed to ``parametrize()``. 
        :param indirect: Same as the ``indirect`` parameter of ``parametrize()``. 
        :raises ValueError: If validation fails. 
        &quot;&quot;&quot;</span>
        <span class="s1">default_arg_names = set(get_default_arg_names(self.function))</span>
        <span class="s1">func_name = self.function.__name__</span>
        <span class="s2">for </span><span class="s1">arg </span><span class="s2">in </span><span class="s1">argnames:</span>
            <span class="s2">if </span><span class="s1">arg </span><span class="s2">not in </span><span class="s1">self.fixturenames:</span>
                <span class="s2">if </span><span class="s1">arg </span><span class="s2">in </span><span class="s1">default_arg_names:</span>
                    <span class="s1">fail(</span>
                        <span class="s3">&quot;In {}: function already takes an argument '{}' with a default value&quot;</span><span class="s1">.format(</span>
                            <span class="s1">func_name</span><span class="s2">, </span><span class="s1">arg</span>
                        <span class="s1">)</span><span class="s2">,</span>
                        <span class="s1">pytrace=</span><span class="s2">False,</span>
                    <span class="s1">)</span>
                <span class="s2">else</span><span class="s1">:</span>
                    <span class="s2">if </span><span class="s1">isinstance(indirect</span><span class="s2">, </span><span class="s1">Sequence):</span>
                        <span class="s1">name = </span><span class="s3">&quot;fixture&quot; </span><span class="s2">if </span><span class="s1">arg </span><span class="s2">in </span><span class="s1">indirect </span><span class="s2">else </span><span class="s3">&quot;argument&quot;</span>
                    <span class="s2">else</span><span class="s1">:</span>
                        <span class="s1">name = </span><span class="s3">&quot;fixture&quot; </span><span class="s2">if </span><span class="s1">indirect </span><span class="s2">else </span><span class="s3">&quot;argument&quot;</span>
                    <span class="s1">fail(</span>
                        <span class="s3">f&quot;In </span><span class="s2">{</span><span class="s1">func_name</span><span class="s2">}</span><span class="s3">: function uses no </span><span class="s2">{</span><span class="s1">name</span><span class="s2">} </span><span class="s3">'</span><span class="s2">{</span><span class="s1">arg</span><span class="s2">}</span><span class="s3">'&quot;</span><span class="s2">,</span>
                        <span class="s1">pytrace=</span><span class="s2">False,</span>
                    <span class="s1">)</span>


<span class="s2">def </span><span class="s1">_find_parametrized_scope(</span>
    <span class="s1">argnames: Sequence[str]</span><span class="s2">,</span>
    <span class="s1">arg2fixturedefs: Mapping[str</span><span class="s2">, </span><span class="s1">Sequence[fixtures.FixtureDef[object]]]</span><span class="s2">,</span>
    <span class="s1">indirect: Union[bool</span><span class="s2">, </span><span class="s1">Sequence[str]]</span><span class="s2">,</span>
<span class="s1">) -&gt; Scope:</span>
    <span class="s0">&quot;&quot;&quot;Find the most appropriate scope for a parametrized call based on its arguments. 
 
    When there's at least one direct argument, always use &quot;function&quot; scope. 
 
    When a test function is parametrized and all its arguments are indirect 
    (e.g. fixtures), return the most narrow scope based on the fixtures used. 
 
    Related to issue #1832, based on code posted by @Kingdread. 
    &quot;&quot;&quot;</span>
    <span class="s2">if </span><span class="s1">isinstance(indirect</span><span class="s2">, </span><span class="s1">Sequence):</span>
        <span class="s1">all_arguments_are_fixtures = len(indirect) == len(argnames)</span>
    <span class="s2">else</span><span class="s1">:</span>
        <span class="s1">all_arguments_are_fixtures = bool(indirect)</span>

    <span class="s2">if </span><span class="s1">all_arguments_are_fixtures:</span>
        <span class="s1">fixturedefs = arg2fixturedefs </span><span class="s2">or </span><span class="s1">{}</span>
        <span class="s1">used_scopes = [</span>
            <span class="s1">fixturedef[</span><span class="s5">0</span><span class="s1">]._scope</span>
            <span class="s2">for </span><span class="s1">name</span><span class="s2">, </span><span class="s1">fixturedef </span><span class="s2">in </span><span class="s1">fixturedefs.items()</span>
            <span class="s2">if </span><span class="s1">name </span><span class="s2">in </span><span class="s1">argnames</span>
        <span class="s1">]</span>
        <span class="s4"># Takes the most narrow scope from used fixtures.</span>
        <span class="s2">return </span><span class="s1">min(used_scopes</span><span class="s2">, </span><span class="s1">default=Scope.Function)</span>

    <span class="s2">return </span><span class="s1">Scope.Function</span>


<span class="s2">def </span><span class="s1">_ascii_escaped_by_config(val: Union[str</span><span class="s2">, </span><span class="s1">bytes]</span><span class="s2">, </span><span class="s1">config: Optional[Config]) -&gt; str:</span>
    <span class="s2">if </span><span class="s1">config </span><span class="s2">is None</span><span class="s1">:</span>
        <span class="s1">escape_option = </span><span class="s2">False</span>
    <span class="s2">else</span><span class="s1">:</span>
        <span class="s1">escape_option = config.getini(</span>
            <span class="s3">&quot;disable_test_id_escaping_and_forfeit_all_rights_to_community_support&quot;</span>
        <span class="s1">)</span>
    <span class="s4"># TODO: If escaping is turned off and the user passes bytes,</span>
    <span class="s4">#       will return a bytes. For now we ignore this but the</span>
    <span class="s4">#       code *probably* doesn't handle this case.</span>
    <span class="s2">return </span><span class="s1">val </span><span class="s2">if </span><span class="s1">escape_option </span><span class="s2">else </span><span class="s1">ascii_escaped(val)  </span><span class="s4"># type: ignore</span>


<span class="s2">def </span><span class="s1">_pretty_fixture_path(func) -&gt; str:</span>
    <span class="s1">cwd = Path.cwd()</span>
    <span class="s1">loc = Path(getlocation(func</span><span class="s2">, </span><span class="s1">str(cwd)))</span>
    <span class="s1">prefix = Path(</span><span class="s3">&quot;...&quot;</span><span class="s2">, </span><span class="s3">&quot;_pytest&quot;</span><span class="s1">)</span>
    <span class="s2">try</span><span class="s1">:</span>
        <span class="s2">return </span><span class="s1">str(prefix / loc.relative_to(_PYTEST_DIR))</span>
    <span class="s2">except </span><span class="s1">ValueError:</span>
        <span class="s2">return </span><span class="s1">bestrelpath(cwd</span><span class="s2">, </span><span class="s1">loc)</span>


<span class="s2">def </span><span class="s1">show_fixtures_per_test(config):</span>
    <span class="s2">from </span><span class="s1">_pytest.main </span><span class="s2">import </span><span class="s1">wrap_session</span>

    <span class="s2">return </span><span class="s1">wrap_session(config</span><span class="s2">, </span><span class="s1">_show_fixtures_per_test)</span>


<span class="s2">def </span><span class="s1">_show_fixtures_per_test(config: Config</span><span class="s2">, </span><span class="s1">session: Session) -&gt; </span><span class="s2">None</span><span class="s1">:</span>
    <span class="s2">import </span><span class="s1">_pytest.config</span>

    <span class="s1">session.perform_collect()</span>
    <span class="s1">curdir = Path.cwd()</span>
    <span class="s1">tw = _pytest.config.create_terminal_writer(config)</span>
    <span class="s1">verbose = config.getvalue(</span><span class="s3">&quot;verbose&quot;</span><span class="s1">)</span>

    <span class="s2">def </span><span class="s1">get_best_relpath(func) -&gt; str:</span>
        <span class="s1">loc = getlocation(func</span><span class="s2">, </span><span class="s1">str(curdir))</span>
        <span class="s2">return </span><span class="s1">bestrelpath(curdir</span><span class="s2">, </span><span class="s1">Path(loc))</span>

    <span class="s2">def </span><span class="s1">write_fixture(fixture_def: fixtures.FixtureDef[object]) -&gt; </span><span class="s2">None</span><span class="s1">:</span>
        <span class="s1">argname = fixture_def.argname</span>
        <span class="s2">if </span><span class="s1">verbose &lt;= </span><span class="s5">0 </span><span class="s2">and </span><span class="s1">argname.startswith(</span><span class="s3">&quot;_&quot;</span><span class="s1">):</span>
            <span class="s2">return</span>
        <span class="s1">prettypath = _pretty_fixture_path(fixture_def.func)</span>
        <span class="s1">tw.write(</span><span class="s3">f&quot;</span><span class="s2">{</span><span class="s1">argname</span><span class="s2">}</span><span class="s3">&quot;</span><span class="s2">, </span><span class="s1">green=</span><span class="s2">True</span><span class="s1">)</span>
        <span class="s1">tw.write(</span><span class="s3">f&quot; -- </span><span class="s2">{</span><span class="s1">prettypath</span><span class="s2">}</span><span class="s3">&quot;</span><span class="s2">, </span><span class="s1">yellow=</span><span class="s2">True</span><span class="s1">)</span>
        <span class="s1">tw.write(</span><span class="s3">&quot;</span><span class="s2">\n</span><span class="s3">&quot;</span><span class="s1">)</span>
        <span class="s1">fixture_doc = inspect.getdoc(fixture_def.func)</span>
        <span class="s2">if </span><span class="s1">fixture_doc:</span>
            <span class="s1">write_docstring(</span>
                <span class="s1">tw</span><span class="s2">, </span><span class="s1">fixture_doc.split(</span><span class="s3">&quot;</span><span class="s2">\n\n</span><span class="s3">&quot;</span><span class="s1">)[</span><span class="s5">0</span><span class="s1">] </span><span class="s2">if </span><span class="s1">verbose &lt;= </span><span class="s5">0 </span><span class="s2">else </span><span class="s1">fixture_doc</span>
            <span class="s1">)</span>
        <span class="s2">else</span><span class="s1">:</span>
            <span class="s1">tw.line(</span><span class="s3">&quot;    no docstring available&quot;</span><span class="s2">, </span><span class="s1">red=</span><span class="s2">True</span><span class="s1">)</span>

    <span class="s2">def </span><span class="s1">write_item(item: nodes.Item) -&gt; </span><span class="s2">None</span><span class="s1">:</span>
        <span class="s4"># Not all items have _fixtureinfo attribute.</span>
        <span class="s1">info: Optional[FuncFixtureInfo] = getattr(item</span><span class="s2">, </span><span class="s3">&quot;_fixtureinfo&quot;</span><span class="s2">, None</span><span class="s1">)</span>
        <span class="s2">if </span><span class="s1">info </span><span class="s2">is None or not </span><span class="s1">info.name2fixturedefs:</span>
            <span class="s4"># This test item does not use any fixtures.</span>
            <span class="s2">return</span>
        <span class="s1">tw.line()</span>
        <span class="s1">tw.sep(</span><span class="s3">&quot;-&quot;</span><span class="s2">, </span><span class="s3">f&quot;fixtures used by </span><span class="s2">{</span><span class="s1">item.name</span><span class="s2">}</span><span class="s3">&quot;</span><span class="s1">)</span>
        <span class="s4"># TODO: Fix this type ignore.</span>
        <span class="s1">tw.sep(</span><span class="s3">&quot;-&quot;</span><span class="s2">, </span><span class="s3">f&quot;(</span><span class="s2">{</span><span class="s1">get_best_relpath(item.function)</span><span class="s2">}</span><span class="s3">)&quot;</span><span class="s1">)  </span><span class="s4"># type: ignore[attr-defined]</span>
        <span class="s4"># dict key not used in loop but needed for sorting.</span>
        <span class="s2">for </span><span class="s1">_</span><span class="s2">, </span><span class="s1">fixturedefs </span><span class="s2">in </span><span class="s1">sorted(info.name2fixturedefs.items()):</span>
            <span class="s2">assert </span><span class="s1">fixturedefs </span><span class="s2">is not None</span>
            <span class="s2">if not </span><span class="s1">fixturedefs:</span>
                <span class="s2">continue</span>
            <span class="s4"># Last item is expected to be the one used by the test item.</span>
            <span class="s1">write_fixture(fixturedefs[-</span><span class="s5">1</span><span class="s1">])</span>

    <span class="s2">for </span><span class="s1">session_item </span><span class="s2">in </span><span class="s1">session.items:</span>
        <span class="s1">write_item(session_item)</span>


<span class="s2">def </span><span class="s1">showfixtures(config: Config) -&gt; Union[int</span><span class="s2">, </span><span class="s1">ExitCode]:</span>
    <span class="s2">from </span><span class="s1">_pytest.main </span><span class="s2">import </span><span class="s1">wrap_session</span>

    <span class="s2">return </span><span class="s1">wrap_session(config</span><span class="s2">, </span><span class="s1">_showfixtures_main)</span>


<span class="s2">def </span><span class="s1">_showfixtures_main(config: Config</span><span class="s2">, </span><span class="s1">session: Session) -&gt; </span><span class="s2">None</span><span class="s1">:</span>
    <span class="s2">import </span><span class="s1">_pytest.config</span>

    <span class="s1">session.perform_collect()</span>
    <span class="s1">curdir = Path.cwd()</span>
    <span class="s1">tw = _pytest.config.create_terminal_writer(config)</span>
    <span class="s1">verbose = config.getvalue(</span><span class="s3">&quot;verbose&quot;</span><span class="s1">)</span>

    <span class="s1">fm = session._fixturemanager</span>

    <span class="s1">available = []</span>
    <span class="s1">seen: Set[Tuple[str</span><span class="s2">, </span><span class="s1">str]] = set()</span>

    <span class="s2">for </span><span class="s1">argname</span><span class="s2">, </span><span class="s1">fixturedefs </span><span class="s2">in </span><span class="s1">fm._arg2fixturedefs.items():</span>
        <span class="s2">assert </span><span class="s1">fixturedefs </span><span class="s2">is not None</span>
        <span class="s2">if not </span><span class="s1">fixturedefs:</span>
            <span class="s2">continue</span>
        <span class="s2">for </span><span class="s1">fixturedef </span><span class="s2">in </span><span class="s1">fixturedefs:</span>
            <span class="s1">loc = getlocation(fixturedef.func</span><span class="s2">, </span><span class="s1">str(curdir))</span>
            <span class="s2">if </span><span class="s1">(fixturedef.argname</span><span class="s2">, </span><span class="s1">loc) </span><span class="s2">in </span><span class="s1">seen:</span>
                <span class="s2">continue</span>
            <span class="s1">seen.add((fixturedef.argname</span><span class="s2">, </span><span class="s1">loc))</span>
            <span class="s1">available.append(</span>
                <span class="s1">(</span>
                    <span class="s1">len(fixturedef.baseid)</span><span class="s2">,</span>
                    <span class="s1">fixturedef.func.__module__</span><span class="s2">,</span>
                    <span class="s1">_pretty_fixture_path(fixturedef.func)</span><span class="s2">,</span>
                    <span class="s1">fixturedef.argname</span><span class="s2">,</span>
                    <span class="s1">fixturedef</span><span class="s2">,</span>
                <span class="s1">)</span>
            <span class="s1">)</span>

    <span class="s1">available.sort()</span>
    <span class="s1">currentmodule = </span><span class="s2">None</span>
    <span class="s2">for </span><span class="s1">baseid</span><span class="s2">, </span><span class="s1">module</span><span class="s2">, </span><span class="s1">prettypath</span><span class="s2">, </span><span class="s1">argname</span><span class="s2">, </span><span class="s1">fixturedef </span><span class="s2">in </span><span class="s1">available:</span>
        <span class="s2">if </span><span class="s1">currentmodule != module:</span>
            <span class="s2">if not </span><span class="s1">module.startswith(</span><span class="s3">&quot;_pytest.&quot;</span><span class="s1">):</span>
                <span class="s1">tw.line()</span>
                <span class="s1">tw.sep(</span><span class="s3">&quot;-&quot;</span><span class="s2">, </span><span class="s3">f&quot;fixtures defined from </span><span class="s2">{</span><span class="s1">module</span><span class="s2">}</span><span class="s3">&quot;</span><span class="s1">)</span>
                <span class="s1">currentmodule = module</span>
        <span class="s2">if </span><span class="s1">verbose &lt;= </span><span class="s5">0 </span><span class="s2">and </span><span class="s1">argname.startswith(</span><span class="s3">&quot;_&quot;</span><span class="s1">):</span>
            <span class="s2">continue</span>
        <span class="s1">tw.write(</span><span class="s3">f&quot;</span><span class="s2">{</span><span class="s1">argname</span><span class="s2">}</span><span class="s3">&quot;</span><span class="s2">, </span><span class="s1">green=</span><span class="s2">True</span><span class="s1">)</span>
        <span class="s2">if </span><span class="s1">fixturedef.scope != </span><span class="s3">&quot;function&quot;</span><span class="s1">:</span>
            <span class="s1">tw.write(</span><span class="s3">&quot; [%s scope]&quot; </span><span class="s1">% fixturedef.scope</span><span class="s2">, </span><span class="s1">cyan=</span><span class="s2">True</span><span class="s1">)</span>
        <span class="s1">tw.write(</span><span class="s3">f&quot; -- </span><span class="s2">{</span><span class="s1">prettypath</span><span class="s2">}</span><span class="s3">&quot;</span><span class="s2">, </span><span class="s1">yellow=</span><span class="s2">True</span><span class="s1">)</span>
        <span class="s1">tw.write(</span><span class="s3">&quot;</span><span class="s2">\n</span><span class="s3">&quot;</span><span class="s1">)</span>
        <span class="s1">doc = inspect.getdoc(fixturedef.func)</span>
        <span class="s2">if </span><span class="s1">doc:</span>
            <span class="s1">write_docstring(tw</span><span class="s2">, </span><span class="s1">doc.split(</span><span class="s3">&quot;</span><span class="s2">\n\n</span><span class="s3">&quot;</span><span class="s1">)[</span><span class="s5">0</span><span class="s1">] </span><span class="s2">if </span><span class="s1">verbose &lt;= </span><span class="s5">0 </span><span class="s2">else </span><span class="s1">doc)</span>
        <span class="s2">else</span><span class="s1">:</span>
            <span class="s1">tw.line(</span><span class="s3">&quot;    no docstring available&quot;</span><span class="s2">, </span><span class="s1">red=</span><span class="s2">True</span><span class="s1">)</span>
        <span class="s1">tw.line()</span>


<span class="s2">def </span><span class="s1">write_docstring(tw: TerminalWriter</span><span class="s2">, </span><span class="s1">doc: str</span><span class="s2">, </span><span class="s1">indent: str = </span><span class="s3">&quot;    &quot;</span><span class="s1">) -&gt; </span><span class="s2">None</span><span class="s1">:</span>
    <span class="s2">for </span><span class="s1">line </span><span class="s2">in </span><span class="s1">doc.split(</span><span class="s3">&quot;</span><span class="s2">\n</span><span class="s3">&quot;</span><span class="s1">):</span>
        <span class="s1">tw.line(indent + line)</span>


<span class="s2">class </span><span class="s1">Function(PyobjMixin</span><span class="s2">, </span><span class="s1">nodes.Item):</span>
    <span class="s0">&quot;&quot;&quot;An Item responsible for setting up and executing a Python test function. 
 
    :param name: 
        The full function name, including any decorations like those 
        added by parametrization (``my_func[my_param]``). 
    :param parent: 
        The parent Node. 
    :param config: 
        The pytest Config object. 
    :param callspec: 
        If given, this is function has been parametrized and the callspec contains 
        meta information about the parametrization. 
    :param callobj: 
        If given, the object which will be called when the Function is invoked, 
        otherwise the callobj will be obtained from ``parent`` using ``originalname``. 
    :param keywords: 
        Keywords bound to the function object for &quot;-k&quot; matching. 
    :param session: 
        The pytest Session object. 
    :param fixtureinfo: 
        Fixture information already resolved at this fixture node.. 
    :param originalname: 
        The attribute name to use for accessing the underlying function object. 
        Defaults to ``name``. Set this if name is different from the original name, 
        for example when it contains decorations like those added by parametrization 
        (``my_func[my_param]``). 
    &quot;&quot;&quot;</span>

    <span class="s4"># Disable since functions handle it themselves.</span>
    <span class="s1">_ALLOW_MARKERS = </span><span class="s2">False</span>

    <span class="s2">def </span><span class="s1">__init__(</span>
        <span class="s1">self</span><span class="s2">,</span>
        <span class="s1">name: str</span><span class="s2">,</span>
        <span class="s1">parent</span><span class="s2">,</span>
        <span class="s1">config: Optional[Config] = </span><span class="s2">None,</span>
        <span class="s1">callspec: Optional[CallSpec2] = </span><span class="s2">None,</span>
        <span class="s1">callobj=NOTSET</span><span class="s2">,</span>
        <span class="s1">keywords: Optional[Mapping[str</span><span class="s2">, </span><span class="s1">Any]] = </span><span class="s2">None,</span>
        <span class="s1">session: Optional[Session] = </span><span class="s2">None,</span>
        <span class="s1">fixtureinfo: Optional[FuncFixtureInfo] = </span><span class="s2">None,</span>
        <span class="s1">originalname: Optional[str] = </span><span class="s2">None,</span>
    <span class="s1">) -&gt; </span><span class="s2">None</span><span class="s1">:</span>
        <span class="s1">super().__init__(name</span><span class="s2">, </span><span class="s1">parent</span><span class="s2">, </span><span class="s1">config=config</span><span class="s2">, </span><span class="s1">session=session)</span>

        <span class="s2">if </span><span class="s1">callobj </span><span class="s2">is not </span><span class="s1">NOTSET:</span>
            <span class="s1">self.obj = callobj</span>

        <span class="s4">#: Original function name, without any decorations (for example</span>
        <span class="s4">#: parametrization adds a ``&quot;[...]&quot;`` suffix to function names), used to access</span>
        <span class="s4">#: the underlying function object from ``parent`` (in case ``callobj`` is not given</span>
        <span class="s4">#: explicitly).</span>
        <span class="s4">#:</span>
        <span class="s4">#: .. versionadded:: 3.0</span>
        <span class="s1">self.originalname = originalname </span><span class="s2">or </span><span class="s1">name</span>

        <span class="s4"># Note: when FunctionDefinition is introduced, we should change ``originalname``</span>
        <span class="s4"># to a readonly property that returns FunctionDefinition.name.</span>

        <span class="s1">self.own_markers.extend(get_unpacked_marks(self.obj))</span>
        <span class="s2">if </span><span class="s1">callspec:</span>
            <span class="s1">self.callspec = callspec</span>
            <span class="s1">self.own_markers.extend(callspec.marks)</span>

        <span class="s4"># todo: this is a hell of a hack</span>
        <span class="s4"># https://github.com/pytest-dev/pytest/issues/4569</span>
        <span class="s4"># Note: the order of the updates is important here; indicates what</span>
        <span class="s4"># takes priority (ctor argument over function attributes over markers).</span>
        <span class="s4"># Take own_markers only; NodeKeywords handles parent traversal on its own.</span>
        <span class="s1">self.keywords.update((mark.name</span><span class="s2">, </span><span class="s1">mark) </span><span class="s2">for </span><span class="s1">mark </span><span class="s2">in </span><span class="s1">self.own_markers)</span>
        <span class="s1">self.keywords.update(self.obj.__dict__)</span>
        <span class="s2">if </span><span class="s1">keywords:</span>
            <span class="s1">self.keywords.update(keywords)</span>

        <span class="s2">if </span><span class="s1">fixtureinfo </span><span class="s2">is None</span><span class="s1">:</span>
            <span class="s1">fixtureinfo = self.session._fixturemanager.getfixtureinfo(</span>
                <span class="s1">self</span><span class="s2">, </span><span class="s1">self.obj</span><span class="s2">, </span><span class="s1">self.cls</span><span class="s2">, </span><span class="s1">funcargs=</span><span class="s2">True</span>
            <span class="s1">)</span>
        <span class="s1">self._fixtureinfo: FuncFixtureInfo = fixtureinfo</span>
        <span class="s1">self.fixturenames = fixtureinfo.names_closure</span>
        <span class="s1">self._initrequest()</span>

    <span class="s1">@classmethod</span>
    <span class="s2">def </span><span class="s1">from_parent(cls</span><span class="s2">, </span><span class="s1">parent</span><span class="s2">, </span><span class="s1">**kw):  </span><span class="s4"># todo: determine sound type limitations</span>
        <span class="s0">&quot;&quot;&quot;The public constructor.&quot;&quot;&quot;</span>
        <span class="s2">return </span><span class="s1">super().from_parent(parent=parent</span><span class="s2">, </span><span class="s1">**kw)</span>

    <span class="s2">def </span><span class="s1">_initrequest(self) -&gt; </span><span class="s2">None</span><span class="s1">:</span>
        <span class="s1">self.funcargs: Dict[str</span><span class="s2">, </span><span class="s1">object] = {}</span>
        <span class="s1">self._request = fixtures.FixtureRequest(self</span><span class="s2">, </span><span class="s1">_ispytest=</span><span class="s2">True</span><span class="s1">)</span>

    <span class="s1">@property</span>
    <span class="s2">def </span><span class="s1">function(self):</span>
        <span class="s0">&quot;&quot;&quot;Underlying python 'function' object.&quot;&quot;&quot;</span>
        <span class="s2">return </span><span class="s1">getimfunc(self.obj)</span>

    <span class="s2">def </span><span class="s1">_getobj(self):</span>
        <span class="s2">assert </span><span class="s1">self.parent </span><span class="s2">is not None</span>
        <span class="s2">if </span><span class="s1">isinstance(self.parent</span><span class="s2">, </span><span class="s1">Class):</span>
            <span class="s4"># Each Function gets a fresh class instance.</span>
            <span class="s1">parent_obj = self.parent.newinstance()</span>
        <span class="s2">else</span><span class="s1">:</span>
            <span class="s1">parent_obj = self.parent.obj  </span><span class="s4"># type: ignore[attr-defined]</span>
        <span class="s2">return </span><span class="s1">getattr(parent_obj</span><span class="s2">, </span><span class="s1">self.originalname)</span>

    <span class="s1">@property</span>
    <span class="s2">def </span><span class="s1">_pyfuncitem(self):</span>
        <span class="s0">&quot;&quot;&quot;(compatonly) for code expecting pytest-2.2 style request objects.&quot;&quot;&quot;</span>
        <span class="s2">return </span><span class="s1">self</span>

    <span class="s2">def </span><span class="s1">runtest(self) -&gt; </span><span class="s2">None</span><span class="s1">:</span>
        <span class="s0">&quot;&quot;&quot;Execute the underlying test function.&quot;&quot;&quot;</span>
        <span class="s1">self.ihook.pytest_pyfunc_call(pyfuncitem=self)</span>

    <span class="s2">def </span><span class="s1">setup(self) -&gt; </span><span class="s2">None</span><span class="s1">:</span>
        <span class="s1">self._request._fillfixtures()</span>

    <span class="s2">def </span><span class="s1">_prunetraceback(self</span><span class="s2">, </span><span class="s1">excinfo: ExceptionInfo[BaseException]) -&gt; </span><span class="s2">None</span><span class="s1">:</span>
        <span class="s2">if </span><span class="s1">hasattr(self</span><span class="s2">, </span><span class="s3">&quot;_obj&quot;</span><span class="s1">) </span><span class="s2">and not </span><span class="s1">self.config.getoption(</span><span class="s3">&quot;fulltrace&quot;</span><span class="s2">, False</span><span class="s1">):</span>
            <span class="s1">code = _pytest._code.Code.from_function(get_real_func(self.obj))</span>
            <span class="s1">path</span><span class="s2">, </span><span class="s1">firstlineno = code.path</span><span class="s2">, </span><span class="s1">code.firstlineno</span>
            <span class="s1">traceback = excinfo.traceback</span>
            <span class="s1">ntraceback = traceback.cut(path=path</span><span class="s2">, </span><span class="s1">firstlineno=firstlineno)</span>
            <span class="s2">if </span><span class="s1">ntraceback == traceback:</span>
                <span class="s1">ntraceback = ntraceback.cut(path=path)</span>
                <span class="s2">if </span><span class="s1">ntraceback == traceback:</span>
                    <span class="s1">ntraceback = ntraceback.filter(filter_traceback)</span>
                    <span class="s2">if not </span><span class="s1">ntraceback:</span>
                        <span class="s1">ntraceback = traceback</span>

            <span class="s1">excinfo.traceback = ntraceback.filter()</span>
            <span class="s4"># issue364: mark all but first and last frames to</span>
            <span class="s4"># only show a single-line message for each frame.</span>
            <span class="s2">if </span><span class="s1">self.config.getoption(</span><span class="s3">&quot;tbstyle&quot;</span><span class="s2">, </span><span class="s3">&quot;auto&quot;</span><span class="s1">) == </span><span class="s3">&quot;auto&quot;</span><span class="s1">:</span>
                <span class="s2">if </span><span class="s1">len(excinfo.traceback) &gt; </span><span class="s5">2</span><span class="s1">:</span>
                    <span class="s2">for </span><span class="s1">entry </span><span class="s2">in </span><span class="s1">excinfo.traceback[</span><span class="s5">1</span><span class="s1">:-</span><span class="s5">1</span><span class="s1">]:</span>
                        <span class="s1">entry.set_repr_style(</span><span class="s3">&quot;short&quot;</span><span class="s1">)</span>

    <span class="s4"># TODO: Type ignored -- breaks Liskov Substitution.</span>
    <span class="s2">def </span><span class="s1">repr_failure(  </span><span class="s4"># type: ignore[override]</span>
        <span class="s1">self</span><span class="s2">,</span>
        <span class="s1">excinfo: ExceptionInfo[BaseException]</span><span class="s2">,</span>
    <span class="s1">) -&gt; Union[str</span><span class="s2">, </span><span class="s1">TerminalRepr]:</span>
        <span class="s1">style = self.config.getoption(</span><span class="s3">&quot;tbstyle&quot;</span><span class="s2">, </span><span class="s3">&quot;auto&quot;</span><span class="s1">)</span>
        <span class="s2">if </span><span class="s1">style == </span><span class="s3">&quot;auto&quot;</span><span class="s1">:</span>
            <span class="s1">style = </span><span class="s3">&quot;long&quot;</span>
        <span class="s2">return </span><span class="s1">self._repr_failure_py(excinfo</span><span class="s2">, </span><span class="s1">style=style)</span>


<span class="s2">class </span><span class="s1">FunctionDefinition(Function):</span>
    <span class="s0">&quot;&quot;&quot; 
    This class is a step gap solution until we evolve to have actual function definition nodes 
    and manage to get rid of ``metafunc``. 
    &quot;&quot;&quot;</span>

    <span class="s2">def </span><span class="s1">runtest(self) -&gt; </span><span class="s2">None</span><span class="s1">:</span>
        <span class="s2">raise </span><span class="s1">RuntimeError(</span><span class="s3">&quot;function definitions are not supposed to be run as tests&quot;</span><span class="s1">)</span>

    <span class="s1">setup = runtest</span>
</pre>
</body>
</html>