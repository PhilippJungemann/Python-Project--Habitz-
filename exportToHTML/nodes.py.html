<html>
<head>
<title>nodes.py</title>
<meta http-equiv="Content-Type" content="text/html; charset=utf-8">
<style type="text/css">
.s0 { color: #cc7832;}
.s1 { color: #a9b7c6;}
.s2 { color: #808080;}
.s3 { color: #6a8759;}
.s4 { color: #629755; font-style: italic;}
.s5 { color: #6897bb;}
</style>
</head>
<body bgcolor="#2b2b2b">
<table CELLSPACING=0 CELLPADDING=5 COLS=1 WIDTH="100%" BGCOLOR="#606060" >
<tr><td><center>
<font face="Arial, Helvetica" color="#000000">
nodes.py</font>
</center></td></tr></table>
<pre><span class="s0">import </span><span class="s1">os</span>
<span class="s0">import </span><span class="s1">warnings</span>
<span class="s0">from </span><span class="s1">inspect </span><span class="s0">import </span><span class="s1">signature</span>
<span class="s0">from </span><span class="s1">pathlib </span><span class="s0">import </span><span class="s1">Path</span>
<span class="s0">from </span><span class="s1">typing </span><span class="s0">import </span><span class="s1">Any</span>
<span class="s0">from </span><span class="s1">typing </span><span class="s0">import </span><span class="s1">Callable</span>
<span class="s0">from </span><span class="s1">typing </span><span class="s0">import </span><span class="s1">cast</span>
<span class="s0">from </span><span class="s1">typing </span><span class="s0">import </span><span class="s1">Iterable</span>
<span class="s0">from </span><span class="s1">typing </span><span class="s0">import </span><span class="s1">Iterator</span>
<span class="s0">from </span><span class="s1">typing </span><span class="s0">import </span><span class="s1">List</span>
<span class="s0">from </span><span class="s1">typing </span><span class="s0">import </span><span class="s1">MutableMapping</span>
<span class="s0">from </span><span class="s1">typing </span><span class="s0">import </span><span class="s1">Optional</span>
<span class="s0">from </span><span class="s1">typing </span><span class="s0">import </span><span class="s1">overload</span>
<span class="s0">from </span><span class="s1">typing </span><span class="s0">import </span><span class="s1">Set</span>
<span class="s0">from </span><span class="s1">typing </span><span class="s0">import </span><span class="s1">Tuple</span>
<span class="s0">from </span><span class="s1">typing </span><span class="s0">import </span><span class="s1">Type</span>
<span class="s0">from </span><span class="s1">typing </span><span class="s0">import </span><span class="s1">TYPE_CHECKING</span>
<span class="s0">from </span><span class="s1">typing </span><span class="s0">import </span><span class="s1">TypeVar</span>
<span class="s0">from </span><span class="s1">typing </span><span class="s0">import </span><span class="s1">Union</span>

<span class="s0">import </span><span class="s1">_pytest._code</span>
<span class="s0">from </span><span class="s1">_pytest._code </span><span class="s0">import </span><span class="s1">getfslineno</span>
<span class="s0">from </span><span class="s1">_pytest._code.code </span><span class="s0">import </span><span class="s1">ExceptionInfo</span>
<span class="s0">from </span><span class="s1">_pytest._code.code </span><span class="s0">import </span><span class="s1">TerminalRepr</span>
<span class="s0">from </span><span class="s1">_pytest.compat </span><span class="s0">import </span><span class="s1">cached_property</span>
<span class="s0">from </span><span class="s1">_pytest.compat </span><span class="s0">import </span><span class="s1">LEGACY_PATH</span>
<span class="s0">from </span><span class="s1">_pytest.config </span><span class="s0">import </span><span class="s1">Config</span>
<span class="s0">from </span><span class="s1">_pytest.config </span><span class="s0">import </span><span class="s1">ConftestImportFailure</span>
<span class="s0">from </span><span class="s1">_pytest.deprecated </span><span class="s0">import </span><span class="s1">FSCOLLECTOR_GETHOOKPROXY_ISINITPATH</span>
<span class="s0">from </span><span class="s1">_pytest.deprecated </span><span class="s0">import </span><span class="s1">NODE_CTOR_FSPATH_ARG</span>
<span class="s0">from </span><span class="s1">_pytest.mark.structures </span><span class="s0">import </span><span class="s1">Mark</span>
<span class="s0">from </span><span class="s1">_pytest.mark.structures </span><span class="s0">import </span><span class="s1">MarkDecorator</span>
<span class="s0">from </span><span class="s1">_pytest.mark.structures </span><span class="s0">import </span><span class="s1">NodeKeywords</span>
<span class="s0">from </span><span class="s1">_pytest.outcomes </span><span class="s0">import </span><span class="s1">fail</span>
<span class="s0">from </span><span class="s1">_pytest.pathlib </span><span class="s0">import </span><span class="s1">absolutepath</span>
<span class="s0">from </span><span class="s1">_pytest.pathlib </span><span class="s0">import </span><span class="s1">commonpath</span>
<span class="s0">from </span><span class="s1">_pytest.stash </span><span class="s0">import </span><span class="s1">Stash</span>
<span class="s0">from </span><span class="s1">_pytest.warning_types </span><span class="s0">import </span><span class="s1">PytestWarning</span>

<span class="s0">if </span><span class="s1">TYPE_CHECKING:</span>
    <span class="s2"># Imported here due to circular import.</span>
    <span class="s0">from </span><span class="s1">_pytest.main </span><span class="s0">import </span><span class="s1">Session</span>
    <span class="s0">from </span><span class="s1">_pytest._code.code </span><span class="s0">import </span><span class="s1">_TracebackStyle</span>


<span class="s1">SEP = </span><span class="s3">&quot;/&quot;</span>

<span class="s1">tracebackcutdir = Path(_pytest.__file__).parent</span>


<span class="s0">def </span><span class="s1">iterparentnodeids(nodeid: str) -&gt; Iterator[str]:</span>
    <span class="s4">&quot;&quot;&quot;Return the parent node IDs of a given node ID, inclusive. 
 
    For the node ID 
 
        &quot;testing/code/test_excinfo.py::TestFormattedExcinfo::test_repr_source&quot; 
 
    the result would be 
 
        &quot;&quot; 
        &quot;testing&quot; 
        &quot;testing/code&quot; 
        &quot;testing/code/test_excinfo.py&quot; 
        &quot;testing/code/test_excinfo.py::TestFormattedExcinfo&quot; 
        &quot;testing/code/test_excinfo.py::TestFormattedExcinfo::test_repr_source&quot; 
 
    Note that / components are only considered until the first ::. 
    &quot;&quot;&quot;</span>
    <span class="s1">pos = </span><span class="s5">0</span>
    <span class="s1">first_colons: Optional[int] = nodeid.find(</span><span class="s3">&quot;::&quot;</span><span class="s1">)</span>
    <span class="s0">if </span><span class="s1">first_colons == -</span><span class="s5">1</span><span class="s1">:</span>
        <span class="s1">first_colons = </span><span class="s0">None</span>
    <span class="s2"># The root Session node - always present.</span>
    <span class="s0">yield </span><span class="s3">&quot;&quot;</span>
    <span class="s2"># Eagerly consume SEP parts until first colons.</span>
    <span class="s0">while True</span><span class="s1">:</span>
        <span class="s1">at = nodeid.find(SEP</span><span class="s0">, </span><span class="s1">pos</span><span class="s0">, </span><span class="s1">first_colons)</span>
        <span class="s0">if </span><span class="s1">at == -</span><span class="s5">1</span><span class="s1">:</span>
            <span class="s0">break</span>
        <span class="s0">if </span><span class="s1">at &gt; </span><span class="s5">0</span><span class="s1">:</span>
            <span class="s0">yield </span><span class="s1">nodeid[:at]</span>
        <span class="s1">pos = at + len(SEP)</span>
    <span class="s2"># Eagerly consume :: parts.</span>
    <span class="s0">while True</span><span class="s1">:</span>
        <span class="s1">at = nodeid.find(</span><span class="s3">&quot;::&quot;</span><span class="s0">, </span><span class="s1">pos)</span>
        <span class="s0">if </span><span class="s1">at == -</span><span class="s5">1</span><span class="s1">:</span>
            <span class="s0">break</span>
        <span class="s0">if </span><span class="s1">at &gt; </span><span class="s5">0</span><span class="s1">:</span>
            <span class="s0">yield </span><span class="s1">nodeid[:at]</span>
        <span class="s1">pos = at + len(</span><span class="s3">&quot;::&quot;</span><span class="s1">)</span>
    <span class="s2"># The node ID itself.</span>
    <span class="s0">if </span><span class="s1">nodeid:</span>
        <span class="s0">yield </span><span class="s1">nodeid</span>


<span class="s0">def </span><span class="s1">_check_path(path: Path</span><span class="s0">, </span><span class="s1">fspath: LEGACY_PATH) -&gt; </span><span class="s0">None</span><span class="s1">:</span>
    <span class="s0">if </span><span class="s1">Path(fspath) != path:</span>
        <span class="s0">raise </span><span class="s1">ValueError(</span>
            <span class="s3">f&quot;Path(</span><span class="s0">{</span><span class="s1">fspath</span><span class="s0">!r}</span><span class="s3">) != </span><span class="s0">{</span><span class="s1">path</span><span class="s0">!r}\n</span><span class="s3">&quot;</span>
            <span class="s3">&quot;if both path and fspath are given they need to be equal&quot;</span>
        <span class="s1">)</span>


<span class="s0">def </span><span class="s1">_imply_path(</span>
    <span class="s1">node_type: Type[</span><span class="s3">&quot;Node&quot;</span><span class="s1">]</span><span class="s0">,</span>
    <span class="s1">path: Optional[Path]</span><span class="s0">,</span>
    <span class="s1">fspath: Optional[LEGACY_PATH]</span><span class="s0">,</span>
<span class="s1">) -&gt; Path:</span>
    <span class="s0">if </span><span class="s1">fspath </span><span class="s0">is not None</span><span class="s1">:</span>
        <span class="s1">warnings.warn(</span>
            <span class="s1">NODE_CTOR_FSPATH_ARG.format(</span>
                <span class="s1">node_type_name=node_type.__name__</span><span class="s0">,</span>
            <span class="s1">)</span><span class="s0">,</span>
            <span class="s1">stacklevel=</span><span class="s5">6</span><span class="s0">,</span>
        <span class="s1">)</span>
    <span class="s0">if </span><span class="s1">path </span><span class="s0">is not None</span><span class="s1">:</span>
        <span class="s0">if </span><span class="s1">fspath </span><span class="s0">is not None</span><span class="s1">:</span>
            <span class="s1">_check_path(path</span><span class="s0">, </span><span class="s1">fspath)</span>
        <span class="s0">return </span><span class="s1">path</span>
    <span class="s0">else</span><span class="s1">:</span>
        <span class="s0">assert </span><span class="s1">fspath </span><span class="s0">is not None</span>
        <span class="s0">return </span><span class="s1">Path(fspath)</span>


<span class="s1">_NodeType = TypeVar(</span><span class="s3">&quot;_NodeType&quot;</span><span class="s0">, </span><span class="s1">bound=</span><span class="s3">&quot;Node&quot;</span><span class="s1">)</span>


<span class="s0">class </span><span class="s1">NodeMeta(type):</span>
    <span class="s0">def </span><span class="s1">__call__(self</span><span class="s0">, </span><span class="s1">*k</span><span class="s0">, </span><span class="s1">**kw):</span>
        <span class="s1">msg = (</span>
            <span class="s3">&quot;Direct construction of {name} has been deprecated, please use {name}.from_parent.</span><span class="s0">\n</span><span class="s3">&quot;</span>
            <span class="s3">&quot;See &quot;</span>
            <span class="s3">&quot;https://docs.pytest.org/en/stable/deprecations.html#node-construction-changed-to-node-from-parent&quot;</span>
            <span class="s3">&quot; for more details.&quot;</span>
        <span class="s1">).format(name=</span><span class="s3">f&quot;</span><span class="s0">{</span><span class="s1">self.__module__</span><span class="s0">}</span><span class="s3">.</span><span class="s0">{</span><span class="s1">self.__name__</span><span class="s0">}</span><span class="s3">&quot;</span><span class="s1">)</span>
        <span class="s1">fail(msg</span><span class="s0">, </span><span class="s1">pytrace=</span><span class="s0">False</span><span class="s1">)</span>

    <span class="s0">def </span><span class="s1">_create(self</span><span class="s0">, </span><span class="s1">*k</span><span class="s0">, </span><span class="s1">**kw):</span>
        <span class="s0">try</span><span class="s1">:</span>
            <span class="s0">return </span><span class="s1">super().__call__(*k</span><span class="s0">, </span><span class="s1">**kw)</span>
        <span class="s0">except </span><span class="s1">TypeError:</span>
            <span class="s1">sig = signature(getattr(self</span><span class="s0">, </span><span class="s3">&quot;__init__&quot;</span><span class="s1">))</span>
            <span class="s1">known_kw = {k: v </span><span class="s0">for </span><span class="s1">k</span><span class="s0">, </span><span class="s1">v </span><span class="s0">in </span><span class="s1">kw.items() </span><span class="s0">if </span><span class="s1">k </span><span class="s0">in </span><span class="s1">sig.parameters}</span>
            <span class="s0">from </span><span class="s1">.warning_types </span><span class="s0">import </span><span class="s1">PytestDeprecationWarning</span>

            <span class="s1">warnings.warn(</span>
                <span class="s1">PytestDeprecationWarning(</span>
                    <span class="s3">f&quot;</span><span class="s0">{</span><span class="s1">self</span><span class="s0">} </span><span class="s3">is not using a cooperative constructor and only takes </span><span class="s0">{</span><span class="s1">set(known_kw)</span><span class="s0">}</span><span class="s3">.</span><span class="s0">\n</span><span class="s3">&quot;</span>
                    <span class="s3">&quot;See https://docs.pytest.org/en/stable/deprecations.html&quot;</span>
                    <span class="s3">&quot;#constructors-of-custom-pytest-node-subclasses-should-take-kwargs &quot;</span>
                    <span class="s3">&quot;for more details.&quot;</span>
                <span class="s1">)</span>
            <span class="s1">)</span>

            <span class="s0">return </span><span class="s1">super().__call__(*k</span><span class="s0">, </span><span class="s1">**known_kw)</span>


<span class="s0">class </span><span class="s1">Node(metaclass=NodeMeta):</span>
    <span class="s4">&quot;&quot;&quot;Base class for Collector and Item, the components of the test 
    collection tree. 
 
    Collector subclasses have children; Items are leaf nodes. 
    &quot;&quot;&quot;</span>

    <span class="s2"># Implemented in the legacypath plugin.</span>
    <span class="s2">#: A ``LEGACY_PATH`` copy of the :attr:`path` attribute. Intended for usage</span>
    <span class="s2">#: for methods not migrated to ``pathlib.Path`` yet, such as</span>
    <span class="s2">#: :meth:`Item.reportinfo`. Will be deprecated in a future release, prefer</span>
    <span class="s2">#: using :attr:`path` instead.</span>
    <span class="s1">fspath: LEGACY_PATH</span>

    <span class="s2"># Use __slots__ to make attribute access faster.</span>
    <span class="s2"># Note that __dict__ is still available.</span>
    <span class="s1">__slots__ = (</span>
        <span class="s3">&quot;name&quot;</span><span class="s0">,</span>
        <span class="s3">&quot;parent&quot;</span><span class="s0">,</span>
        <span class="s3">&quot;config&quot;</span><span class="s0">,</span>
        <span class="s3">&quot;session&quot;</span><span class="s0">,</span>
        <span class="s3">&quot;path&quot;</span><span class="s0">,</span>
        <span class="s3">&quot;_nodeid&quot;</span><span class="s0">,</span>
        <span class="s3">&quot;_store&quot;</span><span class="s0">,</span>
        <span class="s3">&quot;__dict__&quot;</span><span class="s0">,</span>
    <span class="s1">)</span>

    <span class="s0">def </span><span class="s1">__init__(</span>
        <span class="s1">self</span><span class="s0">,</span>
        <span class="s1">name: str</span><span class="s0">,</span>
        <span class="s1">parent: </span><span class="s3">&quot;Optional[Node]&quot; </span><span class="s1">= </span><span class="s0">None,</span>
        <span class="s1">config: Optional[Config] = </span><span class="s0">None,</span>
        <span class="s1">session: </span><span class="s3">&quot;Optional[Session]&quot; </span><span class="s1">= </span><span class="s0">None,</span>
        <span class="s1">fspath: Optional[LEGACY_PATH] = </span><span class="s0">None,</span>
        <span class="s1">path: Optional[Path] = </span><span class="s0">None,</span>
        <span class="s1">nodeid: Optional[str] = </span><span class="s0">None,</span>
    <span class="s1">) -&gt; </span><span class="s0">None</span><span class="s1">:</span>
        <span class="s2">#: A unique name within the scope of the parent node.</span>
        <span class="s1">self.name = name</span>

        <span class="s2">#: The parent collector node.</span>
        <span class="s1">self.parent = parent</span>

        <span class="s0">if </span><span class="s1">config:</span>
            <span class="s2">#: The pytest config object.</span>
            <span class="s1">self.config: Config = config</span>
        <span class="s0">else</span><span class="s1">:</span>
            <span class="s0">if not </span><span class="s1">parent:</span>
                <span class="s0">raise </span><span class="s1">TypeError(</span><span class="s3">&quot;config or parent must be provided&quot;</span><span class="s1">)</span>
            <span class="s1">self.config = parent.config</span>

        <span class="s0">if </span><span class="s1">session:</span>
            <span class="s2">#: The pytest session this node is part of.</span>
            <span class="s1">self.session = session</span>
        <span class="s0">else</span><span class="s1">:</span>
            <span class="s0">if not </span><span class="s1">parent:</span>
                <span class="s0">raise </span><span class="s1">TypeError(</span><span class="s3">&quot;session or parent must be provided&quot;</span><span class="s1">)</span>
            <span class="s1">self.session = parent.session</span>

        <span class="s0">if </span><span class="s1">path </span><span class="s0">is None and </span><span class="s1">fspath </span><span class="s0">is None</span><span class="s1">:</span>
            <span class="s1">path = getattr(parent</span><span class="s0">, </span><span class="s3">&quot;path&quot;</span><span class="s0">, None</span><span class="s1">)</span>
        <span class="s2">#: Filesystem path where this node was collected from (can be None).</span>
        <span class="s1">self.path: Path = _imply_path(type(self)</span><span class="s0">, </span><span class="s1">path</span><span class="s0">, </span><span class="s1">fspath=fspath)</span>

        <span class="s2"># The explicit annotation is to avoid publicly exposing NodeKeywords.</span>
        <span class="s2">#: Keywords/markers collected from all scopes.</span>
        <span class="s1">self.keywords: MutableMapping[str</span><span class="s0">, </span><span class="s1">Any] = NodeKeywords(self)</span>

        <span class="s2">#: The marker objects belonging to this node.</span>
        <span class="s1">self.own_markers: List[Mark] = []</span>

        <span class="s2">#: Allow adding of extra keywords to use for matching.</span>
        <span class="s1">self.extra_keyword_matches: Set[str] = set()</span>

        <span class="s0">if </span><span class="s1">nodeid </span><span class="s0">is not None</span><span class="s1">:</span>
            <span class="s0">assert </span><span class="s3">&quot;::()&quot; </span><span class="s0">not in </span><span class="s1">nodeid</span>
            <span class="s1">self._nodeid = nodeid</span>
        <span class="s0">else</span><span class="s1">:</span>
            <span class="s0">if not </span><span class="s1">self.parent:</span>
                <span class="s0">raise </span><span class="s1">TypeError(</span><span class="s3">&quot;nodeid or parent must be provided&quot;</span><span class="s1">)</span>
            <span class="s1">self._nodeid = self.parent.nodeid + </span><span class="s3">&quot;::&quot; </span><span class="s1">+ self.name</span>

        <span class="s2">#: A place where plugins can store information on the node for their</span>
        <span class="s2">#: own use.</span>
        <span class="s2">#:</span>
        <span class="s2">#: :type: Stash</span>
        <span class="s1">self.stash = Stash()</span>
        <span class="s2"># Deprecated alias. Was never public. Can be removed in a few releases.</span>
        <span class="s1">self._store = self.stash</span>

    <span class="s1">@classmethod</span>
    <span class="s0">def </span><span class="s1">from_parent(cls</span><span class="s0">, </span><span class="s1">parent: </span><span class="s3">&quot;Node&quot;</span><span class="s0">, </span><span class="s1">**kw):</span>
        <span class="s4">&quot;&quot;&quot;Public constructor for Nodes. 
 
        This indirection got introduced in order to enable removing 
        the fragile logic from the node constructors. 
 
        Subclasses can use ``super().from_parent(...)`` when overriding the 
        construction. 
 
        :param parent: The parent node of this Node. 
        &quot;&quot;&quot;</span>
        <span class="s0">if </span><span class="s3">&quot;config&quot; </span><span class="s0">in </span><span class="s1">kw:</span>
            <span class="s0">raise </span><span class="s1">TypeError(</span><span class="s3">&quot;config is not a valid argument for from_parent&quot;</span><span class="s1">)</span>
        <span class="s0">if </span><span class="s3">&quot;session&quot; </span><span class="s0">in </span><span class="s1">kw:</span>
            <span class="s0">raise </span><span class="s1">TypeError(</span><span class="s3">&quot;session is not a valid argument for from_parent&quot;</span><span class="s1">)</span>
        <span class="s0">return </span><span class="s1">cls._create(parent=parent</span><span class="s0">, </span><span class="s1">**kw)</span>

    <span class="s1">@property</span>
    <span class="s0">def </span><span class="s1">ihook(self):</span>
        <span class="s4">&quot;&quot;&quot;fspath-sensitive hook proxy used to call pytest hooks.&quot;&quot;&quot;</span>
        <span class="s0">return </span><span class="s1">self.session.gethookproxy(self.path)</span>

    <span class="s0">def </span><span class="s1">__repr__(self) -&gt; str:</span>
        <span class="s0">return </span><span class="s3">&quot;&lt;{} {}&gt;&quot;</span><span class="s1">.format(self.__class__.__name__</span><span class="s0">, </span><span class="s1">getattr(self</span><span class="s0">, </span><span class="s3">&quot;name&quot;</span><span class="s0">, None</span><span class="s1">))</span>

    <span class="s0">def </span><span class="s1">warn(self</span><span class="s0">, </span><span class="s1">warning: Warning) -&gt; </span><span class="s0">None</span><span class="s1">:</span>
        <span class="s4">&quot;&quot;&quot;Issue a warning for this Node. 
 
        Warnings will be displayed after the test session, unless explicitly suppressed. 
 
        :param Warning warning: 
            The warning instance to issue. 
 
        :raises ValueError: If ``warning`` instance is not a subclass of Warning. 
 
        Example usage: 
 
        .. code-block:: python 
 
            node.warn(PytestWarning(&quot;some message&quot;)) 
            node.warn(UserWarning(&quot;some message&quot;)) 
 
        .. versionchanged:: 6.2 
            Any subclass of :class:`Warning` is now accepted, rather than only 
            :class:`PytestWarning &lt;pytest.PytestWarning&gt;` subclasses. 
        &quot;&quot;&quot;</span>
        <span class="s2"># enforce type checks here to avoid getting a generic type error later otherwise.</span>
        <span class="s0">if not </span><span class="s1">isinstance(warning</span><span class="s0">, </span><span class="s1">Warning):</span>
            <span class="s0">raise </span><span class="s1">ValueError(</span>
                <span class="s3">&quot;warning must be an instance of Warning or subclass, got {!r}&quot;</span><span class="s1">.format(</span>
                    <span class="s1">warning</span>
                <span class="s1">)</span>
            <span class="s1">)</span>
        <span class="s1">path</span><span class="s0">, </span><span class="s1">lineno = get_fslocation_from_item(self)</span>
        <span class="s0">assert </span><span class="s1">lineno </span><span class="s0">is not None</span>
        <span class="s1">warnings.warn_explicit(</span>
            <span class="s1">warning</span><span class="s0">,</span>
            <span class="s1">category=</span><span class="s0">None,</span>
            <span class="s1">filename=str(path)</span><span class="s0">,</span>
            <span class="s1">lineno=lineno + </span><span class="s5">1</span><span class="s0">,</span>
        <span class="s1">)</span>

    <span class="s2"># Methods for ordering nodes.</span>

    <span class="s1">@property</span>
    <span class="s0">def </span><span class="s1">nodeid(self) -&gt; str:</span>
        <span class="s4">&quot;&quot;&quot;A ::-separated string denoting its collection tree address.&quot;&quot;&quot;</span>
        <span class="s0">return </span><span class="s1">self._nodeid</span>

    <span class="s0">def </span><span class="s1">__hash__(self) -&gt; int:</span>
        <span class="s0">return </span><span class="s1">hash(self._nodeid)</span>

    <span class="s0">def </span><span class="s1">setup(self) -&gt; </span><span class="s0">None</span><span class="s1">:</span>
        <span class="s0">pass</span>

    <span class="s0">def </span><span class="s1">teardown(self) -&gt; </span><span class="s0">None</span><span class="s1">:</span>
        <span class="s0">pass</span>

    <span class="s0">def </span><span class="s1">listchain(self) -&gt; List[</span><span class="s3">&quot;Node&quot;</span><span class="s1">]:</span>
        <span class="s4">&quot;&quot;&quot;Return list of all parent collectors up to self, starting from 
        the root of collection tree.&quot;&quot;&quot;</span>
        <span class="s1">chain = []</span>
        <span class="s1">item: Optional[Node] = self</span>
        <span class="s0">while </span><span class="s1">item </span><span class="s0">is not None</span><span class="s1">:</span>
            <span class="s1">chain.append(item)</span>
            <span class="s1">item = item.parent</span>
        <span class="s1">chain.reverse()</span>
        <span class="s0">return </span><span class="s1">chain</span>

    <span class="s0">def </span><span class="s1">add_marker(</span>
        <span class="s1">self</span><span class="s0">, </span><span class="s1">marker: Union[str</span><span class="s0">, </span><span class="s1">MarkDecorator]</span><span class="s0">, </span><span class="s1">append: bool = </span><span class="s0">True</span>
    <span class="s1">) -&gt; </span><span class="s0">None</span><span class="s1">:</span>
        <span class="s4">&quot;&quot;&quot;Dynamically add a marker object to the node. 
 
        :param append: 
            Whether to append the marker, or prepend it. 
        &quot;&quot;&quot;</span>
        <span class="s0">from </span><span class="s1">_pytest.mark </span><span class="s0">import </span><span class="s1">MARK_GEN</span>

        <span class="s0">if </span><span class="s1">isinstance(marker</span><span class="s0">, </span><span class="s1">MarkDecorator):</span>
            <span class="s1">marker_ = marker</span>
        <span class="s0">elif </span><span class="s1">isinstance(marker</span><span class="s0">, </span><span class="s1">str):</span>
            <span class="s1">marker_ = getattr(MARK_GEN</span><span class="s0">, </span><span class="s1">marker)</span>
        <span class="s0">else</span><span class="s1">:</span>
            <span class="s0">raise </span><span class="s1">ValueError(</span><span class="s3">&quot;is not a string or pytest.mark.* Marker&quot;</span><span class="s1">)</span>
        <span class="s1">self.keywords[marker_.name] = marker_</span>
        <span class="s0">if </span><span class="s1">append:</span>
            <span class="s1">self.own_markers.append(marker_.mark)</span>
        <span class="s0">else</span><span class="s1">:</span>
            <span class="s1">self.own_markers.insert(</span><span class="s5">0</span><span class="s0">, </span><span class="s1">marker_.mark)</span>

    <span class="s0">def </span><span class="s1">iter_markers(self</span><span class="s0">, </span><span class="s1">name: Optional[str] = </span><span class="s0">None</span><span class="s1">) -&gt; Iterator[Mark]:</span>
        <span class="s4">&quot;&quot;&quot;Iterate over all markers of the node. 
 
        :param name: If given, filter the results by the name attribute. 
        &quot;&quot;&quot;</span>
        <span class="s0">return </span><span class="s1">(x[</span><span class="s5">1</span><span class="s1">] </span><span class="s0">for </span><span class="s1">x </span><span class="s0">in </span><span class="s1">self.iter_markers_with_node(name=name))</span>

    <span class="s0">def </span><span class="s1">iter_markers_with_node(</span>
        <span class="s1">self</span><span class="s0">, </span><span class="s1">name: Optional[str] = </span><span class="s0">None</span>
    <span class="s1">) -&gt; Iterator[Tuple[</span><span class="s3">&quot;Node&quot;</span><span class="s0">, </span><span class="s1">Mark]]:</span>
        <span class="s4">&quot;&quot;&quot;Iterate over all markers of the node. 
 
        :param name: If given, filter the results by the name attribute. 
        :returns: An iterator of (node, mark) tuples. 
        &quot;&quot;&quot;</span>
        <span class="s0">for </span><span class="s1">node </span><span class="s0">in </span><span class="s1">reversed(self.listchain()):</span>
            <span class="s0">for </span><span class="s1">mark </span><span class="s0">in </span><span class="s1">node.own_markers:</span>
                <span class="s0">if </span><span class="s1">name </span><span class="s0">is None or </span><span class="s1">getattr(mark</span><span class="s0">, </span><span class="s3">&quot;name&quot;</span><span class="s0">, None</span><span class="s1">) == name:</span>
                    <span class="s0">yield </span><span class="s1">node</span><span class="s0">, </span><span class="s1">mark</span>

    <span class="s1">@overload</span>
    <span class="s0">def </span><span class="s1">get_closest_marker(self</span><span class="s0">, </span><span class="s1">name: str) -&gt; Optional[Mark]:</span>
        <span class="s1">...</span>

    <span class="s1">@overload</span>
    <span class="s0">def </span><span class="s1">get_closest_marker(self</span><span class="s0">, </span><span class="s1">name: str</span><span class="s0">, </span><span class="s1">default: Mark) -&gt; Mark:</span>
        <span class="s1">...</span>

    <span class="s0">def </span><span class="s1">get_closest_marker(</span>
        <span class="s1">self</span><span class="s0">, </span><span class="s1">name: str</span><span class="s0">, </span><span class="s1">default: Optional[Mark] = </span><span class="s0">None</span>
    <span class="s1">) -&gt; Optional[Mark]:</span>
        <span class="s4">&quot;&quot;&quot;Return the first marker matching the name, from closest (for 
        example function) to farther level (for example module level). 
 
        :param default: Fallback return value if no marker was found. 
        :param name: Name to filter by. 
        &quot;&quot;&quot;</span>
        <span class="s0">return </span><span class="s1">next(self.iter_markers(name=name)</span><span class="s0">, </span><span class="s1">default)</span>

    <span class="s0">def </span><span class="s1">listextrakeywords(self) -&gt; Set[str]:</span>
        <span class="s4">&quot;&quot;&quot;Return a set of all extra keywords in self and any parents.&quot;&quot;&quot;</span>
        <span class="s1">extra_keywords: Set[str] = set()</span>
        <span class="s0">for </span><span class="s1">item </span><span class="s0">in </span><span class="s1">self.listchain():</span>
            <span class="s1">extra_keywords.update(item.extra_keyword_matches)</span>
        <span class="s0">return </span><span class="s1">extra_keywords</span>

    <span class="s0">def </span><span class="s1">listnames(self) -&gt; List[str]:</span>
        <span class="s0">return </span><span class="s1">[x.name </span><span class="s0">for </span><span class="s1">x </span><span class="s0">in </span><span class="s1">self.listchain()]</span>

    <span class="s0">def </span><span class="s1">addfinalizer(self</span><span class="s0">, </span><span class="s1">fin: Callable[[]</span><span class="s0">, </span><span class="s1">object]) -&gt; </span><span class="s0">None</span><span class="s1">:</span>
        <span class="s4">&quot;&quot;&quot;Register a function to be called when this node is finalized. 
 
        This method can only be called when this node is active 
        in a setup chain, for example during self.setup(). 
        &quot;&quot;&quot;</span>
        <span class="s1">self.session._setupstate.addfinalizer(fin</span><span class="s0">, </span><span class="s1">self)</span>

    <span class="s0">def </span><span class="s1">getparent(self</span><span class="s0">, </span><span class="s1">cls: Type[_NodeType]) -&gt; Optional[_NodeType]:</span>
        <span class="s4">&quot;&quot;&quot;Get the next parent node (including self) which is an instance of 
        the given class.&quot;&quot;&quot;</span>
        <span class="s1">current: Optional[Node] = self</span>
        <span class="s0">while </span><span class="s1">current </span><span class="s0">and not </span><span class="s1">isinstance(current</span><span class="s0">, </span><span class="s1">cls):</span>
            <span class="s1">current = current.parent</span>
        <span class="s0">assert </span><span class="s1">current </span><span class="s0">is None or </span><span class="s1">isinstance(current</span><span class="s0">, </span><span class="s1">cls)</span>
        <span class="s0">return </span><span class="s1">current</span>

    <span class="s0">def </span><span class="s1">_prunetraceback(self</span><span class="s0">, </span><span class="s1">excinfo: ExceptionInfo[BaseException]) -&gt; </span><span class="s0">None</span><span class="s1">:</span>
        <span class="s0">pass</span>

    <span class="s0">def </span><span class="s1">_repr_failure_py(</span>
        <span class="s1">self</span><span class="s0">,</span>
        <span class="s1">excinfo: ExceptionInfo[BaseException]</span><span class="s0">,</span>
        <span class="s1">style: </span><span class="s3">&quot;Optional[_TracebackStyle]&quot; </span><span class="s1">= </span><span class="s0">None,</span>
    <span class="s1">) -&gt; TerminalRepr:</span>
        <span class="s0">from </span><span class="s1">_pytest.fixtures </span><span class="s0">import </span><span class="s1">FixtureLookupError</span>

        <span class="s0">if </span><span class="s1">isinstance(excinfo.value</span><span class="s0">, </span><span class="s1">ConftestImportFailure):</span>
            <span class="s1">excinfo = ExceptionInfo.from_exc_info(excinfo.value.excinfo)</span>
        <span class="s0">if </span><span class="s1">isinstance(excinfo.value</span><span class="s0">, </span><span class="s1">fail.Exception):</span>
            <span class="s0">if not </span><span class="s1">excinfo.value.pytrace:</span>
                <span class="s1">style = </span><span class="s3">&quot;value&quot;</span>
        <span class="s0">if </span><span class="s1">isinstance(excinfo.value</span><span class="s0">, </span><span class="s1">FixtureLookupError):</span>
            <span class="s0">return </span><span class="s1">excinfo.value.formatrepr()</span>
        <span class="s0">if </span><span class="s1">self.config.getoption(</span><span class="s3">&quot;fulltrace&quot;</span><span class="s0">, False</span><span class="s1">):</span>
            <span class="s1">style = </span><span class="s3">&quot;long&quot;</span>
        <span class="s0">else</span><span class="s1">:</span>
            <span class="s1">tb = _pytest._code.Traceback([excinfo.traceback[-</span><span class="s5">1</span><span class="s1">]])</span>
            <span class="s1">self._prunetraceback(excinfo)</span>
            <span class="s0">if </span><span class="s1">len(excinfo.traceback) == </span><span class="s5">0</span><span class="s1">:</span>
                <span class="s1">excinfo.traceback = tb</span>
            <span class="s0">if </span><span class="s1">style == </span><span class="s3">&quot;auto&quot;</span><span class="s1">:</span>
                <span class="s1">style = </span><span class="s3">&quot;long&quot;</span>
        <span class="s2"># XXX should excinfo.getrepr record all data and toterminal() process it?</span>
        <span class="s0">if </span><span class="s1">style </span><span class="s0">is None</span><span class="s1">:</span>
            <span class="s0">if </span><span class="s1">self.config.getoption(</span><span class="s3">&quot;tbstyle&quot;</span><span class="s0">, </span><span class="s3">&quot;auto&quot;</span><span class="s1">) == </span><span class="s3">&quot;short&quot;</span><span class="s1">:</span>
                <span class="s1">style = </span><span class="s3">&quot;short&quot;</span>
            <span class="s0">else</span><span class="s1">:</span>
                <span class="s1">style = </span><span class="s3">&quot;long&quot;</span>

        <span class="s0">if </span><span class="s1">self.config.getoption(</span><span class="s3">&quot;verbose&quot;</span><span class="s0">, </span><span class="s5">0</span><span class="s1">) &gt; </span><span class="s5">1</span><span class="s1">:</span>
            <span class="s1">truncate_locals = </span><span class="s0">False</span>
        <span class="s0">else</span><span class="s1">:</span>
            <span class="s1">truncate_locals = </span><span class="s0">True</span>

        <span class="s2"># excinfo.getrepr() formats paths relative to the CWD if `abspath` is False.</span>
        <span class="s2"># It is possible for a fixture/test to change the CWD while this code runs, which</span>
        <span class="s2"># would then result in the user seeing confusing paths in the failure message.</span>
        <span class="s2"># To fix this, if the CWD changed, always display the full absolute path.</span>
        <span class="s2"># It will be better to just always display paths relative to invocation_dir, but</span>
        <span class="s2"># this requires a lot of plumbing (#6428).</span>
        <span class="s0">try</span><span class="s1">:</span>
            <span class="s1">abspath = Path(os.getcwd()) != self.config.invocation_params.dir</span>
        <span class="s0">except </span><span class="s1">OSError:</span>
            <span class="s1">abspath = </span><span class="s0">True</span>

        <span class="s0">return </span><span class="s1">excinfo.getrepr(</span>
            <span class="s1">funcargs=</span><span class="s0">True,</span>
            <span class="s1">abspath=abspath</span><span class="s0">,</span>
            <span class="s1">showlocals=self.config.getoption(</span><span class="s3">&quot;showlocals&quot;</span><span class="s0">, False</span><span class="s1">)</span><span class="s0">,</span>
            <span class="s1">style=style</span><span class="s0">,</span>
            <span class="s1">tbfilter=</span><span class="s0">False,  </span><span class="s2"># pruned already, or in --fulltrace mode.</span>
            <span class="s1">truncate_locals=truncate_locals</span><span class="s0">,</span>
        <span class="s1">)</span>

    <span class="s0">def </span><span class="s1">repr_failure(</span>
        <span class="s1">self</span><span class="s0">,</span>
        <span class="s1">excinfo: ExceptionInfo[BaseException]</span><span class="s0">,</span>
        <span class="s1">style: </span><span class="s3">&quot;Optional[_TracebackStyle]&quot; </span><span class="s1">= </span><span class="s0">None,</span>
    <span class="s1">) -&gt; Union[str</span><span class="s0">, </span><span class="s1">TerminalRepr]:</span>
        <span class="s4">&quot;&quot;&quot;Return a representation of a collection or test failure. 
 
        .. seealso:: :ref:`non-python tests` 
 
        :param excinfo: Exception information for the failure. 
        &quot;&quot;&quot;</span>
        <span class="s0">return </span><span class="s1">self._repr_failure_py(excinfo</span><span class="s0">, </span><span class="s1">style)</span>


<span class="s0">def </span><span class="s1">get_fslocation_from_item(node: </span><span class="s3">&quot;Node&quot;</span><span class="s1">) -&gt; Tuple[Union[str</span><span class="s0">, </span><span class="s1">Path]</span><span class="s0">, </span><span class="s1">Optional[int]]:</span>
    <span class="s4">&quot;&quot;&quot;Try to extract the actual location from a node, depending on available attributes: 
 
    * &quot;location&quot;: a pair (path, lineno) 
    * &quot;obj&quot;: a Python object that the node wraps. 
    * &quot;fspath&quot;: just a path 
 
    :rtype: A tuple of (str|Path, int) with filename and line number. 
    &quot;&quot;&quot;</span>
    <span class="s2"># See Item.location.</span>
    <span class="s1">location: Optional[Tuple[str</span><span class="s0">, </span><span class="s1">Optional[int]</span><span class="s0">, </span><span class="s1">str]] = getattr(node</span><span class="s0">, </span><span class="s3">&quot;location&quot;</span><span class="s0">, None</span><span class="s1">)</span>
    <span class="s0">if </span><span class="s1">location </span><span class="s0">is not None</span><span class="s1">:</span>
        <span class="s0">return </span><span class="s1">location[:</span><span class="s5">2</span><span class="s1">]</span>
    <span class="s1">obj = getattr(node</span><span class="s0">, </span><span class="s3">&quot;obj&quot;</span><span class="s0">, None</span><span class="s1">)</span>
    <span class="s0">if </span><span class="s1">obj </span><span class="s0">is not None</span><span class="s1">:</span>
        <span class="s0">return </span><span class="s1">getfslineno(obj)</span>
    <span class="s0">return </span><span class="s1">getattr(node</span><span class="s0">, </span><span class="s3">&quot;fspath&quot;</span><span class="s0">, </span><span class="s3">&quot;unknown location&quot;</span><span class="s1">)</span><span class="s0">, </span><span class="s1">-</span><span class="s5">1</span>


<span class="s0">class </span><span class="s1">Collector(Node):</span>
    <span class="s4">&quot;&quot;&quot;Collector instances create children through collect() and thus 
    iteratively build a tree.&quot;&quot;&quot;</span>

    <span class="s0">class </span><span class="s1">CollectError(Exception):</span>
        <span class="s4">&quot;&quot;&quot;An error during collection, contains a custom message.&quot;&quot;&quot;</span>

    <span class="s0">def </span><span class="s1">collect(self) -&gt; Iterable[Union[</span><span class="s3">&quot;Item&quot;</span><span class="s0">, </span><span class="s3">&quot;Collector&quot;</span><span class="s1">]]:</span>
        <span class="s4">&quot;&quot;&quot;Return a list of children (items and collectors) for this 
        collection node.&quot;&quot;&quot;</span>
        <span class="s0">raise </span><span class="s1">NotImplementedError(</span><span class="s3">&quot;abstract&quot;</span><span class="s1">)</span>

    <span class="s2"># TODO: This omits the style= parameter which breaks Liskov Substitution.</span>
    <span class="s0">def </span><span class="s1">repr_failure(  </span><span class="s2"># type: ignore[override]</span>
        <span class="s1">self</span><span class="s0">, </span><span class="s1">excinfo: ExceptionInfo[BaseException]</span>
    <span class="s1">) -&gt; Union[str</span><span class="s0">, </span><span class="s1">TerminalRepr]:</span>
        <span class="s4">&quot;&quot;&quot;Return a representation of a collection failure. 
 
        :param excinfo: Exception information for the failure. 
        &quot;&quot;&quot;</span>
        <span class="s0">if </span><span class="s1">isinstance(excinfo.value</span><span class="s0">, </span><span class="s1">self.CollectError) </span><span class="s0">and not </span><span class="s1">self.config.getoption(</span>
            <span class="s3">&quot;fulltrace&quot;</span><span class="s0">, False</span>
        <span class="s1">):</span>
            <span class="s1">exc = excinfo.value</span>
            <span class="s0">return </span><span class="s1">str(exc.args[</span><span class="s5">0</span><span class="s1">])</span>

        <span class="s2"># Respect explicit tbstyle option, but default to &quot;short&quot;</span>
        <span class="s2"># (_repr_failure_py uses &quot;long&quot; with &quot;fulltrace&quot; option always).</span>
        <span class="s1">tbstyle = self.config.getoption(</span><span class="s3">&quot;tbstyle&quot;</span><span class="s0">, </span><span class="s3">&quot;auto&quot;</span><span class="s1">)</span>
        <span class="s0">if </span><span class="s1">tbstyle == </span><span class="s3">&quot;auto&quot;</span><span class="s1">:</span>
            <span class="s1">tbstyle = </span><span class="s3">&quot;short&quot;</span>

        <span class="s0">return </span><span class="s1">self._repr_failure_py(excinfo</span><span class="s0">, </span><span class="s1">style=tbstyle)</span>

    <span class="s0">def </span><span class="s1">_prunetraceback(self</span><span class="s0">, </span><span class="s1">excinfo: ExceptionInfo[BaseException]) -&gt; </span><span class="s0">None</span><span class="s1">:</span>
        <span class="s0">if </span><span class="s1">hasattr(self</span><span class="s0">, </span><span class="s3">&quot;path&quot;</span><span class="s1">):</span>
            <span class="s1">traceback = excinfo.traceback</span>
            <span class="s1">ntraceback = traceback.cut(path=self.path)</span>
            <span class="s0">if </span><span class="s1">ntraceback == traceback:</span>
                <span class="s1">ntraceback = ntraceback.cut(excludepath=tracebackcutdir)</span>
            <span class="s1">excinfo.traceback = ntraceback.filter()</span>


<span class="s0">def </span><span class="s1">_check_initialpaths_for_relpath(session: </span><span class="s3">&quot;Session&quot;</span><span class="s0">, </span><span class="s1">path: Path) -&gt; Optional[str]:</span>
    <span class="s0">for </span><span class="s1">initial_path </span><span class="s0">in </span><span class="s1">session._initialpaths:</span>
        <span class="s0">if </span><span class="s1">commonpath(path</span><span class="s0">, </span><span class="s1">initial_path) == initial_path:</span>
            <span class="s1">rel = str(path.relative_to(initial_path))</span>
            <span class="s0">return </span><span class="s3">&quot;&quot; </span><span class="s0">if </span><span class="s1">rel == </span><span class="s3">&quot;.&quot; </span><span class="s0">else </span><span class="s1">rel</span>
    <span class="s0">return None</span>


<span class="s0">class </span><span class="s1">FSCollector(Collector):</span>
    <span class="s0">def </span><span class="s1">__init__(</span>
        <span class="s1">self</span><span class="s0">,</span>
        <span class="s1">fspath: Optional[LEGACY_PATH] = </span><span class="s0">None,</span>
        <span class="s1">path_or_parent: Optional[Union[Path</span><span class="s0">, </span><span class="s1">Node]] = </span><span class="s0">None,</span>
        <span class="s1">path: Optional[Path] = </span><span class="s0">None,</span>
        <span class="s1">name: Optional[str] = </span><span class="s0">None,</span>
        <span class="s1">parent: Optional[Node] = </span><span class="s0">None,</span>
        <span class="s1">config: Optional[Config] = </span><span class="s0">None,</span>
        <span class="s1">session: Optional[</span><span class="s3">&quot;Session&quot;</span><span class="s1">] = </span><span class="s0">None,</span>
        <span class="s1">nodeid: Optional[str] = </span><span class="s0">None,</span>
    <span class="s1">) -&gt; </span><span class="s0">None</span><span class="s1">:</span>
        <span class="s0">if </span><span class="s1">path_or_parent:</span>
            <span class="s0">if </span><span class="s1">isinstance(path_or_parent</span><span class="s0">, </span><span class="s1">Node):</span>
                <span class="s0">assert </span><span class="s1">parent </span><span class="s0">is None</span>
                <span class="s1">parent = cast(FSCollector</span><span class="s0">, </span><span class="s1">path_or_parent)</span>
            <span class="s0">elif </span><span class="s1">isinstance(path_or_parent</span><span class="s0">, </span><span class="s1">Path):</span>
                <span class="s0">assert </span><span class="s1">path </span><span class="s0">is None</span>
                <span class="s1">path = path_or_parent</span>

        <span class="s1">path = _imply_path(type(self)</span><span class="s0">, </span><span class="s1">path</span><span class="s0">, </span><span class="s1">fspath=fspath)</span>
        <span class="s0">if </span><span class="s1">name </span><span class="s0">is None</span><span class="s1">:</span>
            <span class="s1">name = path.name</span>
            <span class="s0">if </span><span class="s1">parent </span><span class="s0">is not None and </span><span class="s1">parent.path != path:</span>
                <span class="s0">try</span><span class="s1">:</span>
                    <span class="s1">rel = path.relative_to(parent.path)</span>
                <span class="s0">except </span><span class="s1">ValueError:</span>
                    <span class="s0">pass</span>
                <span class="s0">else</span><span class="s1">:</span>
                    <span class="s1">name = str(rel)</span>
                <span class="s1">name = name.replace(os.sep</span><span class="s0">, </span><span class="s1">SEP)</span>
        <span class="s1">self.path = path</span>

        <span class="s0">if </span><span class="s1">session </span><span class="s0">is None</span><span class="s1">:</span>
            <span class="s0">assert </span><span class="s1">parent </span><span class="s0">is not None</span>
            <span class="s1">session = parent.session</span>

        <span class="s0">if </span><span class="s1">nodeid </span><span class="s0">is None</span><span class="s1">:</span>
            <span class="s0">try</span><span class="s1">:</span>
                <span class="s1">nodeid = str(self.path.relative_to(session.config.rootpath))</span>
            <span class="s0">except </span><span class="s1">ValueError:</span>
                <span class="s1">nodeid = _check_initialpaths_for_relpath(session</span><span class="s0">, </span><span class="s1">path)</span>

            <span class="s0">if </span><span class="s1">nodeid </span><span class="s0">and </span><span class="s1">os.sep != SEP:</span>
                <span class="s1">nodeid = nodeid.replace(os.sep</span><span class="s0">, </span><span class="s1">SEP)</span>

        <span class="s1">super().__init__(</span>
            <span class="s1">name=name</span><span class="s0">,</span>
            <span class="s1">parent=parent</span><span class="s0">,</span>
            <span class="s1">config=config</span><span class="s0">,</span>
            <span class="s1">session=session</span><span class="s0">,</span>
            <span class="s1">nodeid=nodeid</span><span class="s0">,</span>
            <span class="s1">path=path</span><span class="s0">,</span>
        <span class="s1">)</span>

    <span class="s1">@classmethod</span>
    <span class="s0">def </span><span class="s1">from_parent(</span>
        <span class="s1">cls</span><span class="s0">,</span>
        <span class="s1">parent</span><span class="s0">,</span>
        <span class="s1">*</span><span class="s0">,</span>
        <span class="s1">fspath: Optional[LEGACY_PATH] = </span><span class="s0">None,</span>
        <span class="s1">path: Optional[Path] = </span><span class="s0">None,</span>
        <span class="s1">**kw</span><span class="s0">,</span>
    <span class="s1">):</span>
        <span class="s4">&quot;&quot;&quot;The public constructor.&quot;&quot;&quot;</span>
        <span class="s0">return </span><span class="s1">super().from_parent(parent=parent</span><span class="s0">, </span><span class="s1">fspath=fspath</span><span class="s0">, </span><span class="s1">path=path</span><span class="s0">, </span><span class="s1">**kw)</span>

    <span class="s0">def </span><span class="s1">gethookproxy(self</span><span class="s0">, </span><span class="s1">fspath: </span><span class="s3">&quot;os.PathLike[str]&quot;</span><span class="s1">):</span>
        <span class="s1">warnings.warn(FSCOLLECTOR_GETHOOKPROXY_ISINITPATH</span><span class="s0">, </span><span class="s1">stacklevel=</span><span class="s5">2</span><span class="s1">)</span>
        <span class="s0">return </span><span class="s1">self.session.gethookproxy(fspath)</span>

    <span class="s0">def </span><span class="s1">isinitpath(self</span><span class="s0">, </span><span class="s1">path: Union[str</span><span class="s0">, </span><span class="s3">&quot;os.PathLike[str]&quot;</span><span class="s1">]) -&gt; bool:</span>
        <span class="s1">warnings.warn(FSCOLLECTOR_GETHOOKPROXY_ISINITPATH</span><span class="s0">, </span><span class="s1">stacklevel=</span><span class="s5">2</span><span class="s1">)</span>
        <span class="s0">return </span><span class="s1">self.session.isinitpath(path)</span>


<span class="s0">class </span><span class="s1">File(FSCollector):</span>
    <span class="s4">&quot;&quot;&quot;Base class for collecting tests from a file. 
 
    :ref:`non-python tests`. 
    &quot;&quot;&quot;</span>


<span class="s0">class </span><span class="s1">Item(Node):</span>
    <span class="s4">&quot;&quot;&quot;A basic test invocation item. 
 
    Note that for a single function there might be multiple test invocation items. 
    &quot;&quot;&quot;</span>

    <span class="s1">nextitem = </span><span class="s0">None</span>

    <span class="s0">def </span><span class="s1">__init__(</span>
        <span class="s1">self</span><span class="s0">,</span>
        <span class="s1">name</span><span class="s0">,</span>
        <span class="s1">parent=</span><span class="s0">None,</span>
        <span class="s1">config: Optional[Config] = </span><span class="s0">None,</span>
        <span class="s1">session: Optional[</span><span class="s3">&quot;Session&quot;</span><span class="s1">] = </span><span class="s0">None,</span>
        <span class="s1">nodeid: Optional[str] = </span><span class="s0">None,</span>
        <span class="s1">**kw</span><span class="s0">,</span>
    <span class="s1">) -&gt; </span><span class="s0">None</span><span class="s1">:</span>
        <span class="s2"># The first two arguments are intentionally passed positionally,</span>
        <span class="s2"># to keep plugins who define a node type which inherits from</span>
        <span class="s2"># (pytest.Item, pytest.File) working (see issue #8435).</span>
        <span class="s2"># They can be made kwargs when the deprecation above is done.</span>
        <span class="s1">super().__init__(</span>
            <span class="s1">name</span><span class="s0">,</span>
            <span class="s1">parent</span><span class="s0">,</span>
            <span class="s1">config=config</span><span class="s0">,</span>
            <span class="s1">session=session</span><span class="s0">,</span>
            <span class="s1">nodeid=nodeid</span><span class="s0">,</span>
            <span class="s1">**kw</span><span class="s0">,</span>
        <span class="s1">)</span>
        <span class="s1">self._report_sections: List[Tuple[str</span><span class="s0">, </span><span class="s1">str</span><span class="s0">, </span><span class="s1">str]] = []</span>

        <span class="s2">#: A list of tuples (name, value) that holds user defined properties</span>
        <span class="s2">#: for this test.</span>
        <span class="s1">self.user_properties: List[Tuple[str</span><span class="s0">, </span><span class="s1">object]] = []</span>

        <span class="s1">self._check_item_and_collector_diamond_inheritance()</span>

    <span class="s0">def </span><span class="s1">_check_item_and_collector_diamond_inheritance(self) -&gt; </span><span class="s0">None</span><span class="s1">:</span>
        <span class="s4">&quot;&quot;&quot; 
        Check if the current type inherits from both File and Collector 
        at the same time, emitting a warning accordingly (#8447). 
        &quot;&quot;&quot;</span>
        <span class="s1">cls = type(self)</span>

        <span class="s2"># We inject an attribute in the type to avoid issuing this warning</span>
        <span class="s2"># for the same class more than once, which is not helpful.</span>
        <span class="s2"># It is a hack, but was deemed acceptable in order to avoid</span>
        <span class="s2"># flooding the user in the common case.</span>
        <span class="s1">attr_name = </span><span class="s3">&quot;_pytest_diamond_inheritance_warning_shown&quot;</span>
        <span class="s0">if </span><span class="s1">getattr(cls</span><span class="s0">, </span><span class="s1">attr_name</span><span class="s0">, False</span><span class="s1">):</span>
            <span class="s0">return</span>
        <span class="s1">setattr(cls</span><span class="s0">, </span><span class="s1">attr_name</span><span class="s0">, True</span><span class="s1">)</span>

        <span class="s1">problems = </span><span class="s3">&quot;, &quot;</span><span class="s1">.join(</span>
            <span class="s1">base.__name__ </span><span class="s0">for </span><span class="s1">base </span><span class="s0">in </span><span class="s1">cls.__bases__ </span><span class="s0">if </span><span class="s1">issubclass(base</span><span class="s0">, </span><span class="s1">Collector)</span>
        <span class="s1">)</span>
        <span class="s0">if </span><span class="s1">problems:</span>
            <span class="s1">warnings.warn(</span>
                <span class="s3">f&quot;</span><span class="s0">{</span><span class="s1">cls.__name__</span><span class="s0">} </span><span class="s3">is an Item subclass and should not be a collector, &quot;</span>
                <span class="s3">f&quot;however its bases </span><span class="s0">{</span><span class="s1">problems</span><span class="s0">} </span><span class="s3">are collectors.</span><span class="s0">\n</span><span class="s3">&quot;</span>
                <span class="s3">&quot;Please split the Collectors and the Item into separate node types.</span><span class="s0">\n</span><span class="s3">&quot;</span>
                <span class="s3">&quot;Pytest Doc example: https://docs.pytest.org/en/latest/example/nonpython.html</span><span class="s0">\n</span><span class="s3">&quot;</span>
                <span class="s3">&quot;example pull request on a plugin: https://github.com/asmeurer/pytest-flakes/pull/40/&quot;</span><span class="s0">,</span>
                <span class="s1">PytestWarning</span><span class="s0">,</span>
            <span class="s1">)</span>

    <span class="s0">def </span><span class="s1">runtest(self) -&gt; </span><span class="s0">None</span><span class="s1">:</span>
        <span class="s4">&quot;&quot;&quot;Run the test case for this item. 
 
        Must be implemented by subclasses. 
 
        .. seealso:: :ref:`non-python tests` 
        &quot;&quot;&quot;</span>
        <span class="s0">raise </span><span class="s1">NotImplementedError(</span><span class="s3">&quot;runtest must be implemented by Item subclass&quot;</span><span class="s1">)</span>

    <span class="s0">def </span><span class="s1">add_report_section(self</span><span class="s0">, </span><span class="s1">when: str</span><span class="s0">, </span><span class="s1">key: str</span><span class="s0">, </span><span class="s1">content: str) -&gt; </span><span class="s0">None</span><span class="s1">:</span>
        <span class="s4">&quot;&quot;&quot;Add a new report section, similar to what's done internally to add 
        stdout and stderr captured output:: 
 
            item.add_report_section(&quot;call&quot;, &quot;stdout&quot;, &quot;report section contents&quot;) 
 
        :param str when: 
            One of the possible capture states, ``&quot;setup&quot;``, ``&quot;call&quot;``, ``&quot;teardown&quot;``. 
        :param str key: 
            Name of the section, can be customized at will. Pytest uses ``&quot;stdout&quot;`` and 
            ``&quot;stderr&quot;`` internally. 
        :param str content: 
            The full contents as a string. 
        &quot;&quot;&quot;</span>
        <span class="s0">if </span><span class="s1">content:</span>
            <span class="s1">self._report_sections.append((when</span><span class="s0">, </span><span class="s1">key</span><span class="s0">, </span><span class="s1">content))</span>

    <span class="s0">def </span><span class="s1">reportinfo(self) -&gt; Tuple[Union[</span><span class="s3">&quot;os.PathLike[str]&quot;</span><span class="s0">, </span><span class="s1">str]</span><span class="s0">, </span><span class="s1">Optional[int]</span><span class="s0">, </span><span class="s1">str]:</span>
        <span class="s4">&quot;&quot;&quot;Get location information for this item for test reports. 
 
        Returns a tuple with three elements: 
 
        - The path of the test (default ``self.path``) 
        - The line number of the test (default ``None``) 
        - A name of the test to be shown (default ``&quot;&quot;``) 
 
        .. seealso:: :ref:`non-python tests` 
        &quot;&quot;&quot;</span>
        <span class="s0">return </span><span class="s1">self.path</span><span class="s0">, None, </span><span class="s3">&quot;&quot;</span>

    <span class="s1">@cached_property</span>
    <span class="s0">def </span><span class="s1">location(self) -&gt; Tuple[str</span><span class="s0">, </span><span class="s1">Optional[int]</span><span class="s0">, </span><span class="s1">str]:</span>
        <span class="s1">location = self.reportinfo()</span>
        <span class="s1">path = absolutepath(os.fspath(location[</span><span class="s5">0</span><span class="s1">]))</span>
        <span class="s1">relfspath = self.session._node_location_to_relpath(path)</span>
        <span class="s0">assert </span><span class="s1">type(location[</span><span class="s5">2</span><span class="s1">]) </span><span class="s0">is </span><span class="s1">str</span>
        <span class="s0">return </span><span class="s1">(relfspath</span><span class="s0">, </span><span class="s1">location[</span><span class="s5">1</span><span class="s1">]</span><span class="s0">, </span><span class="s1">location[</span><span class="s5">2</span><span class="s1">])</span>
</pre>
</body>
</html>